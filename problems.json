[
  {
    "id": "buy-and-sell-stock",
    "title": "Buy & Sell Stock ",
    "topic": "Arrays",
    "difficulty": "Easy",
    "tags": "sliding window",
    "statement": "Write the problem statement here in Markdown.\r\n\r\nYou are given an integer array prices where prices[i] is the price of a given stock on the ith day.\r\n\r\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\r\n\r\nFind and return the maximum profit you can achieve.\r\n\r\nExample 1:\r\n\r\nInput: prices = [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Total profit is 4 + 3 = 7. Example 2:\r\n\r\nInput: prices = [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Total profit is 4. Example 3:\r\n\r\nInput: prices = [7,6,4,3,1] Output: 0 Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.",
    "solution": "class Solution {\r\n    public int maxProfit(int[] prices) {\r\n        int max = Integer.MIN_VALUE;\r\n        int buy = prices[0];\r\n        for(int i=1;i<prices.length;i++){\r\n            int profit = prices[i] - buy;\r\n            if(profit > 0)\r\n                max = Math.max(max,profit);\r\n            buy = Math.min(buy,prices[i]);\r\n        }\r\n\r\n        return max == Integer.MIN_VALUE ? 0 : max;\r\n    }\r\n}"
  },
  {
    "id": "majority-element",
    "title": "Majority Element",
    "topic": "Arrays",
    "difficulty": "Easy",
    "tags": "sliding window",
    "statement": "Given an array nums of size n, return the majority element.\r\n\r\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [3,2,3]\r\nOutput: 3\r\nExample 2:\r\n\r\nInput: nums = [2,2,1,1,1,2,2]\r\nOutput: 2\r\n ",
    "solution": "class Solution {\r\n    public int majorityElement(int[] nums) {\r\n        int count =1;\r\n        int ans = nums[0];\r\n        for(int i=1;i<nums.length;i++){\r\n            if(nums[i] != ans){\r\n                count--;    \r\n                if(count == 0){\r\n                    count=1;\r\n                    ans = nums[i];\r\n                }\r\n            }\r\n            else {\r\n                count++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}"
  },
  {
    "id": "meeting-rooms",
    "title": "Meeting Room",
    "topic": "Arrays",
    "difficulty": "Easy",
    "tags": "Intervals",
    "statement": "Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i), determine if a person could add all meetings to their schedule without any conflicts.\r\n\r\nExample 1:\r\n\r\nInput: intervals = [(0,30),(5,10),(15,20)]\r\n\r\nOutput: false\r\nExplanation:\r\n\r\n(0,30) and (5,10) will conflict\r\n(0,30) and (15,20) will conflict\r\nExample 2:\r\n\r\nInput: intervals = [(5,8),(9,15)]\r\n\r\nOutput: true\r\nNote:\r\n\r\n(0,8),(8,10) is not considered a conflict at 8",
    "solution": "/**\r\n * Definition of Interval:\r\n * public class Interval {\r\n *     public int start, end;\r\n *     public Interval(int start, int end) {\r\n *         this.start = start;\r\n *         this.end = end;\r\n *     }\r\n * }\r\n */\r\n\r\nclass Solution {\r\n    public boolean canAttendMeetings(List<Interval> intervals) {\r\n        int n = intervals.size();\r\n        Collections.sort(intervals, (a,b) -> a.start - b.start);\r\n\r\n        for(int i=1;i<n;i++){\r\n            if(intervals.get(i).start < intervals.get(i-1).end ){\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n\r\n    }\r\n}"
  },
  {
    "id": "insert-interval",
    "title": "Insert Interval",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "Intervals",
    "statement": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\r\n\r\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\r\n\r\nReturn intervals after the insertion.\r\n\r\nNote that you don't need to modify intervals in-place. You can make a new array and return it.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\r\nOutput: [[1,5],[6,9]]\r\nExample 2:\r\n\r\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\r\nOutput: [[1,2],[3,10],[12,16]]\r\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].",
    "solution": "class Solution {\r\n    public int[][] insert(int[][] intervals, int[] newInterval) {\r\n       List<int[]> output = new ArrayList<>();\r\n       Arrays.sort(intervals,(a,b) -> a[0] - b[0]);\r\n\r\n       for(int i=0;i<intervals.length;i++){\r\n\r\n        if(newInterval != null && newInterval[1] < intervals[i][0]){\r\n            output.add(newInterval);\r\n            output.add(intervals[i]);\r\n            newInterval = null;\r\n        }\r\n        else if(newInterval != null && intervals[i][1] >= newInterval[0]){\r\n            newInterval[0] = Math.min(intervals[i][0],newInterval[0]);\r\n            newInterval[1] = Math.max(intervals[i][1],newInterval[1]);\r\n        }\r\n        else {\r\n            output.add(intervals[i]);\r\n        }\r\n       }\r\n\r\n       if(newInterval != null){\r\n        output.add(newInterval);\r\n       }\r\n\r\n       int[][] out = new int[output.size()][2];\r\n\r\n       for(int i=0;i<output.size();i++){\r\n        out[i][0] = output.get(i)[0];\r\n        out[i][1] = output.get(i)[1];\r\n       }\r\n\r\n       return out;\r\n\r\n\r\n    }\r\n}"
  },
  {
    "id": "3sum",
    "title": "3Sum",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "sliding window",
    "statement": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\r\n\r\nNotice that the solution set must not contain duplicate triplets.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [-1,0,1,2,-1,-4]\r\nOutput: [[-1,-1,2],[-1,0,1]]\r\nExplanation: \r\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\r\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\r\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\r\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\r\nNotice that the order of the output and the order of the triplets does not matter.\r\nExample 2:\r\n\r\nInput: nums = [0,1,1]\r\nOutput: []\r\nExplanation: The only possible triplet does not sum up to 0.\r\nExample 3:\r\n\r\nInput: nums = [0,0,0]\r\nOutput: [[0,0,0]]\r\nExplanation: The only possible triplet sums up to 0.",
    "solution": "class Solution {\r\n    public List<List<Integer>> threeSum(int[] nums) {\r\n        HashSet<List<Integer>> output = new HashSet<>();\r\n\r\n        int n = nums.length;\r\n        Arrays.sort(nums);\r\n\r\n        for(int i=0;i<n;i++){\r\n            // a + b + c = 0; a+b = -c\r\n            if(i!=0 && nums[i] == nums[i-1])\r\n                continue;\r\n\r\n            int temp = -1 * nums[i];\r\n            HashSet<Integer> hs = new HashSet<>();\r\n            for(int j=i+1;j<n;j++){\r\n                int target = temp - nums[j];\r\n                if(hs.contains(target)){\r\n                    output.add(Arrays.asList(nums[i],nums[j],target));\r\n                }\r\n                else {\r\n                    hs.add(nums[j]);\r\n                }\r\n            }\r\n        }\r\n        \r\n        return new ArrayList<List<Integer>>(output);\r\n    }\r\n}\r\n\r\n// [-4,-1,-1,0,1,2]"
  },
  {
    "id": "product-array-except-self",
    "title": "Product of Array Except Self",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "",
    "statement": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\r\n\r\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\r\n\r\nYou must write an algorithm that runs in O(n) time and without using the division operation.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,4]\r\nOutput: [24,12,8,6]\r\nExample 2:\r\n\r\nInput: nums = [-1,1,0,-3,3]\r\nOutput: [0,0,9,0,0]",
    "solution": "class Solution {\r\n    public int[] productExceptSelf(int[] nums) {\r\n        int n = nums.length;\r\n        int[] output = new int[n];\r\n        int left = 1;\r\n        output[0] = 1;\r\n        for(int i=1;i<n;i++){\r\n            left = left * nums[i-1];\r\n            output[i] = left;\r\n        }\r\n\r\n        int right = 1;\r\n        for(int i=n-2;i>=0;i--){\r\n            right = right * nums[i+1];\r\n            output[i] = output[i] * right;\r\n        }\r\n\r\n        return output;\r\n    }\r\n}\r\n\r\n// [1,2,3,4] -> [1,1,2,6] -> [24,12,8,6]"
  },
  {
    "id": "combination-sum",
    "title": "Combination Sum",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "Backtracking",
    "statement": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\r\n\r\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\r\n\r\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: candidates = [2,3,6,7], target = 7\r\nOutput: [[2,2,3],[7]]\r\nExplanation:\r\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\r\n7 is a candidate, and 7 = 7.\r\nThese are the only two combinations.\r\nExample 2:\r\n\r\nInput: candidates = [2,3,5], target = 8\r\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\r\nExample 3:\r\n\r\nInput: candidates = [2], target = 1\r\nOutput: []",
    "solution": "class Solution {\r\n    List<List<Integer>> output = new ArrayList<>();\r\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\r\n        dfs(candidates,target,0,0,new ArrayList<Integer>());\r\n        return output;\r\n    }\r\n\r\n    public void dfs(int[] can, int target, int sum, int index, List<Integer> list){\r\n        if(sum > target)\r\n            return;\r\n        if(sum == target){\r\n            output.add(new ArrayList<>(list));\r\n        }\r\n\r\n        for(int i=index;i<can.length;i++){\r\n\r\n            list.add(can[i]);\r\n            dfs(can,target,sum+can[i],i,list);\r\n            list.remove(list.size() -1);\r\n        }\r\n    }\r\n}"
  },
  {
    "id": "merge-intervals",
    "title": "Merge Intervals",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "Intervals",
    "statement": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\r\nOutput: [[1,6],[8,10],[15,18]]\r\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\r\nExample 2:\r\n\r\nInput: intervals = [[1,4],[4,5]]\r\nOutput: [[1,5]]\r\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\r\nExample 3:\r\n\r\nInput: intervals = [[4,7],[1,4]]\r\nOutput: [[1,7]]\r\nExplanation: Intervals [1,4] and [4,7] are considered overlapping.",
    "solution": "class Solution {\r\n    public int[][] merge(int[][] intervals) {\r\n        Arrays.sort(intervals,(a,b) -> a[0] - b[0]);\r\n        int n = intervals.length;\r\n        int start = intervals[0][0];\r\n        int end = intervals[0][1];\r\n\r\n        List<int[]> output = new ArrayList<>();\r\n\r\n        for(int i=1;i<n;i++){\r\n            if(end < intervals[i][0]){\r\n                output.add(new int[]{start,end});\r\n                start = intervals[i][0];\r\n                end = intervals[i][1];\r\n            }\r\n            else if(end != -1 && end >= intervals[i][0]){\r\n                start = Math.min(start,intervals[i][0]);\r\n                end = Math.max(end,intervals[i][1]);\r\n            }\r\n            else {\r\n                output.add(intervals[i]);\r\n            }\r\n        }\r\n\r\n        if(start != -1 && end != -1){\r\n            output.add(new int[]{start,end});\r\n        }\r\n\r\n        int[][] out = new int[output.size()][2];\r\n\r\n        for(int i=0;i<output.size();i++){\r\n            out[i][0] = output.get(i)[0];\r\n            out[i][1] = output.get(i)[1];\r\n        }\r\n\r\n        return out; \r\n    }\r\n}"
  },
  {
    "id": "sort-color",
    "title": "Sort Color",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "Two pointers",
    "statement": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\r\n\r\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\r\n\r\nYou must solve this problem without using the library's sort function.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [2,0,2,1,1,0]\r\nOutput: [0,0,1,1,2,2]\r\nExample 2:\r\n\r\nInput: nums = [2,0,1]\r\nOutput: [0,1,2]",
    "solution": "class Solution {\r\n    public void sortColors(int[] nums) {\r\n        int n = nums.length;\r\n        int red = 0; // (color 0)\r\n        int white = 0; // color 1\r\n        int blue = n -1; // color 2\r\n\r\n        while(white <= blue){\r\n            if(nums[white] == 0){\r\n                int temp = nums[red];\r\n                nums[red] = nums[white]; // 0\r\n                nums[white] = temp;\r\n                red++;\r\n                white++;\r\n            }\r\n            else if(nums[white] == 1){\r\n                white++;\r\n            }\r\n            else {\r\n                int temp = nums[blue];\r\n                nums[blue] = nums[white];\r\n                nums[white] = temp;\r\n                blue--;\r\n            }\r\n\r\n        }\r\n    }\r\n}"
  },
  {
    "id": "container-with-most-water",
    "title": "Container with most water",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "Two pointers",
    "statement": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\r\n\r\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\r\n\r\nReturn the maximum amount of water a container can store.\r\n\r\nNotice that you may not slant the container. Input: height = [1,8,6,2,5,4,8,3,7]\r\nOutput: 49\r\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\r\nExample 2:\r\n\r\nInput: height = [1,1]\r\nOutput: 1\r\n ",
    "solution": "class Solution {\r\n    public int maxArea(int[] height) {\r\n        int n = height.length;\r\n        int i=0, j= n-1;\r\n        int ans = Integer.MIN_VALUE;\r\n\r\n        while(i<j){\r\n            int h = Math.min(height[i],height[j]);\r\n            ans = Math.max(ans,h*(j-i));\r\n            if(height[i] < height[j]) i++;\r\n            else j--;\r\n        }\r\n        return ans;\r\n    }\r\n}"
  },
  {
    "id": "gas-station",
    "title": "Gas Station",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "Two pointers",
    "statement": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\r\n\r\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\r\n\r\nGiven two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\r\nOutput: 3\r\nExplanation:\r\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\r\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\r\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\r\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\r\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\r\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\r\nTherefore, return 3 as the starting index.\r\nExample 2:\r\n\r\nInput: gas = [2,3,4], cost = [3,4,3]\r\nOutput: -1\r\nExplanation:\r\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\r\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\r\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\r\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\r\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\r\nTherefore, you can't travel around the circuit once no matter where you start.",
    "solution": "class Solution {\r\n    public int canCompleteCircuit(int[] gas, int[] cost) {\r\n        int totalGas = 0;\r\n        int totalCost =0;\r\n        int n=gas.length;\r\n        for(int i=0;i<n;i++){\r\n            totalGas = totalGas + gas[i];\r\n            totalCost = totalCost + cost[i];\r\n        }\r\n\r\n        if(totalCost > totalGas)\r\n            return -1;\r\n        int idx = 0;\r\n        int runningSum =0;\r\n        for(int i=0;i<n;i++){\r\n            runningSum = runningSum + gas[i];\r\n            if(runningSum - cost[i] < 0){\r\n                idx = i+1;\r\n                runningSum =0;\r\n            }\r\n            else {\r\n                runningSum = runningSum - cost[i];\r\n            }\r\n        }\r\n        return idx;\r\n    }\r\n}"
  },
  {
    "id": "longest-consecutive-sequence",
    "title": "Longest Consecutive Sequence",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "sliding window",
    "statement": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\r\n\r\nYou must write an algorithm that runs in O(n) time.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [100,4,200,1,3,2]\r\nOutput: 4\r\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\r\nExample 2:\r\n\r\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\r\nOutput: 9\r\nExample 3:\r\n\r\nInput: nums = [1,0,1,2]\r\nOutput: 3",
    "solution": "class Solution {\r\n    public int longestConsecutive(int[] nums) {\r\n        Set<Integer> hs = new HashSet<>();\r\n        for(int a: nums){\r\n            hs.add(a);\r\n        }\r\n        int max =0;\r\n        for(int n: hs){\r\n            if(!hs.contains(n-1)){\r\n                int currStreak = n + 1;\r\n                \r\n                while(hs.contains(currStreak)){\r\n                    currStreak++;\r\n                }\r\n                \r\n                max = Math.max(max,currStreak - n);\r\n            }\r\n        }\r\n        \r\n        return max;\r\n    }\r\n}"
  },
  {
    "id": "rotate-array",
    "title": "Rotate Array",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "Two pointers",
    "statement": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,4,5,6,7], k = 3\r\nOutput: [5,6,7,1,2,3,4]\r\nExplanation:\r\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\r\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\r\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\r\nExample 2:\r\n\r\nInput: nums = [-1,-100,3,99], k = 2\r\nOutput: [3,99,-1,-100]\r\nExplanation: \r\nrotate 1 steps to the right: [99,-1,-100,3]\r\nrotate 2 steps to the right: [3,99,-1,-100]",
    "solution": "class Solution {\r\n    public void rotate(int[] nums, int k) {\r\n        int n = nums.length;\r\n        int count=0;\r\n        for(int curr=0;count < n;curr++){\r\n            int startIndex = curr;\r\n            int currIndex = curr;\r\n            int prevValue = nums[curr];\r\n            do {\r\n                currIndex = (currIndex + k ) % n;\r\n                int nextValue = nums[currIndex];\r\n                nums[currIndex] = prevValue;\r\n                prevValue = nextValue;\r\n                count++;\r\n            }while(startIndex != currIndex);\r\n\r\n        }\r\n    }\r\n}\r\n\r\n// [1,2,3,4,5,6,7]\r\n// []"
  },
  {
    "id": "contiguous-array",
    "title": "Contiguous Array",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "Prefix Sum",
    "statement": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [0,1]\r\nOutput: 2\r\nExplanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\r\nExample 2:\r\n\r\nInput: nums = [0,1,0]\r\nOutput: 2\r\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\r\nExample 3:\r\n\r\nInput: nums = [0,1,1,1,1,1,0,0,0]\r\nOutput: 6\r\nExplanation: [1,1,1,0,0,0] is the longest contiguous subarray with equal number of 0 and 1.",
    "solution": "class Solution {\r\n    public int findMaxLength(int[] nums) {\r\n        HashMap<Integer,Integer> hm = new HashMap<>();\r\n        hm.put(0,-1);\r\n        int count =0, ans = 0;\r\n        for(int i=0;i<nums.length;i++){\r\n            count = count + (nums[i] == 0 ? -1 : 1);\r\n            if(hm.containsKey(count)){\r\n                ans = Math.max(ans,i - hm.get(count));\r\n            }\r\n            else {\r\n                hm.put(count,i);\r\n            }\r\n        }\r\n        return ans;      \r\n    }\r\n}\r\n\r\n// [0,1,1,1,1,1,0,0,0]\r\n// [-1,0,1,2,3,4,3,2,1]"
  },
  {
    "id": "subarray-sum-equals-to-k",
    "title": "Subarray sum equals to K",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "HashTable",
    "statement": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\r\n\r\nA subarray is a contiguous non-empty sequence of elements within an array.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,1,1], k = 2\r\nOutput: 2\r\nExample 2:\r\n\r\nInput: nums = [1,2,3], k = 3\r\nOutput: 2",
    "solution": "class Solution {\r\n    public int subarraySum(int[] nums, int k) {\r\n        HashMap<Integer,Integer> map = new HashMap<>();\r\n        int total =0, count =0;\r\n        map.put(0,1);\r\n\r\n        for(int n: nums){\r\n            total = total + n;\r\n\r\n            if(map.containsKey(total - k)){\r\n                count = count + map.get(total -k);\r\n            }\r\n\r\n            map.put(total,map.getOrDefault(total,0)+1);\r\n        }\r\n\r\n        return count;\r\n    }\r\n}"
  },
  {
    "id": "meeting-rooms-ii",
    "title": "Meeting Room II",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "Heap",
    "statement": "Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i), find the minimum number of days required to schedule all meetings without any conflicts.\r\n\r\nNote: (0,8),(8,10) is not considered a conflict at 8.\r\n\r\nExample 1:\r\n\r\nInput: intervals = [(0,40),(5,10),(15,20)]\r\n\r\nOutput: 2\r\nExplanation:\r\nday1: (0,40)\r\nday2: (5,10),(15,20)\r\n\r\nExample 2:\r\n\r\nInput: intervals = [(4,9)]\r\n\r\nOutput: 1",
    "solution": "/**\r\n * Definition of Interval:\r\n * public class Interval {\r\n *     public int start, end;\r\n *     public Interval(int start, int end) {\r\n *         this.start = start;\r\n *         this.end = end;\r\n *     }\r\n * }\r\n */\r\n\r\nclass Solution {\r\n    public int minMeetingRooms(List<Interval> intervals) {\r\n        usingheap(intervals);\r\n        List<Integer> start = new ArrayList<>();\r\n        List<Integer> end = new ArrayList<>();\r\n        for(Interval i : intervals){\r\n            start.add(i.start);\r\n            end.add(i.end);\r\n        }    \r\n\r\n        Collections.sort(start);\r\n        Collections.sort(end);\r\n\r\n        int i=0,j=0,count=0,max=0;\r\n\r\n        while(i<intervals.size()){\r\n            if(start.get(i) < end.get(j)){\r\n                count++;\r\n                i++;\r\n            }\r\n            else {\r\n                j++;\r\n                count--;\r\n            }\r\n\r\n            max = Math.max(max,count);\r\n            \r\n        }\r\n        return max;\r\n\r\n        \r\n\r\n    }\r\n    \r\n    public int usingheap(List<Interval> intervals){\r\n        Collections.sort(intervals, (a,b) -> a.start - b.start);\r\n\r\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\r\n\r\n        for(int i=0;i<intervals.size();i++){\r\n            while(!pq.isEmpty() && intervals.get(i).end >= pq.peek() ){\r\n                pq.poll();\r\n            }\r\n            pq.offer(intervals.get(i).end);\r\n        }\r\n\r\n        return pq.size();\r\n    }\r\n}"
  },
  {
    "id": "3sum-closest",
    "title": "3Sum Closest",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "Two pointers",
    "statement": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\r\n\r\nReturn the sum of the three integers.\r\n\r\nYou may assume that each input would have exactly one solution.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [-1,2,1,-4], target = 1\r\nOutput: 2\r\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\r\nExample 2:\r\n\r\nInput: nums = [0,0,0], target = 1\r\nOutput: 0\r\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).",
    "solution": "class Solution {\r\n    public int threeSumClosest(int[] nums, int target) {\r\n        int min = Integer.MAX_VALUE, val=0;\r\n\r\n        Arrays.sort(nums);\r\n        for(int i=0;i<nums.length;i++){\r\n            int temp = nums[i];\r\n            int j=i+1, k=nums.length-1;\r\n            while(j<k){\r\n                int m = temp + nums[j] + nums[k];\r\n                if(min > Math.abs(target-m)){\r\n                    min = Math.abs(target-m);\r\n                    val = m;\r\n                }\r\n                \r\n                if( m > target){\r\n                    k--;\r\n                }\r\n                else {\r\n                    j++;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return val;\r\n    }\r\n}"
  },
  {
    "id": "non-overlapping-intervals",
    "title": "Non-overlapping Intervals",
    "topic": "Arrays",
    "difficulty": "Medium",
    "tags": "Intervals",
    "statement": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\r\n\r\nNote that intervals which only touch at a point are non-overlapping. For example, [1, 2] and [2, 3] are non-overlapping.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]\r\nOutput: 1\r\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\r\nExample 2:\r\n\r\nInput: intervals = [[1,2],[1,2],[1,2]]\r\nOutput: 2\r\nExplanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\r\nExample 3:\r\n\r\nInput: intervals = [[1,2],[2,3]]\r\nOutput: 0\r\nExplanation: You don't need to remove any of the intervals since they're already non-overlapping.",
    "solution": "class Solution {\r\n    public int eraseOverlapIntervals(int[][] intervals) {\r\n        Arrays.sort(intervals,(a,b) -> a[0] - b[0]);\r\n        int count =0;\r\n        int end = intervals[0][1];\r\n        for(int i=1;i<intervals.length;i++){\r\n            if(end > intervals[i][0]){\r\n                count++;\r\n                end = Math.min(end,intervals[i][1]);\r\n            }\r\n            else {\r\n                end = intervals[i][1];\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n}"
  },
  {
    "id": "sliding-window-maximum",
    "title": "Sliding window Maximum",
    "topic": "Arrays",
    "difficulty": "Hard",
    "tags": "Heap",
    "statement": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\r\n\r\nReturn the max sliding window.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\r\nOutput: [3,3,5,5,6,7]\r\nExplanation: \r\nWindow position                Max\r\n---------------               -----\r\n[1  3  -1] -3  5  3  6  7       3\r\n 1 [3  -1  -3] 5  3  6  7       3\r\n 1  3 [-1  -3  5] 3  6  7       5\r\n 1  3  -1 [-3  5  3] 6  7       5\r\n 1  3  -1  -3 [5  3  6] 7       6\r\n 1  3  -1  -3  5 [3  6  7]      7\r\nExample 2:\r\n\r\nInput: nums = [1], k = 1\r\nOutput: [1]",
    "solution": "class Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> nums[b] - nums[a]);\r\n        List<Integer> out = new ArrayList<>();\r\n        for(int i=0;i<nums.length;i++){\r\n            pq.add(i);\r\n            while(!pq.isEmpty() && pq.peek() <= (i-k)){\r\n                pq.poll();\r\n            }\r\n            if(i >= k - 1){\r\n                out.add(nums[pq.peek()]);\r\n            }\r\n        }\r\n        return out.stream().mapToInt(Integer::intValue).toArray();\r\n    }\r\n}"
  },
  {
    "id": "employee-free-time",
    "title": "Employee Free Time",
    "topic": "Arrays",
    "difficulty": "Hard",
    "tags": "Heap",
    "statement": "Given a list of employee work schedules with each employee having a list of non-overlapping intervals representing their working hours, we are tasked with finding the common free time for all employees, or in other words, the times when all employees are not working.\r\n\r\nThe input is a nested list of intervals, each interval as [start, end], with start < end. The intervals are non-overlapping and are already sorted in ascending order. The output should also be a list of sorted intervals.\r\n\r\nFor example, consider schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]. Here, Employee 1 works from 1 to 3 and 6 to 7. Employee 2 works from 2 to 4 and Employee 3 works from 2 to 5 and 9 to 12. The common free time for all employees is [5,6] and [7,9] as these are the intervals when all employees are free.",
    "solution": " public List<Interval> employeeFreeTime(List<List<Interval>> schedule) {\r\n        List<Interval> res = new ArrayList<>();\r\n        List<Interval> intervals = new ArrayList<>();\r\n        // Flattening the schedule\r\n        for (List<Interval> employee : schedule)\r\n            for (Interval interval : employee)\r\n                intervals.add(interval);\r\n        // Sorting by start of each Interval\r\n        Collections.sort(intervals, (a, b) -> a.start - b.start);\r\n        int end = intervals.get(0).end;\r\n        // Checking for free time between intervals\r\n        for (Interval interval : intervals) {\r\n            if (interval.start > end)\r\n                res.add(new Interval(end, interval.start));\r\n            end = Math.max(end, interval.end);\r\n        }\r\n        return res;\r\n    }"
  },
  {
    "id": "evaluate-reverse-pollish-notation",
    "title": "Evaluate Reverse Polish Notation",
    "topic": "Stack",
    "difficulty": "Medium",
    "tags": "Stack",
    "statement": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\r\n\r\nEvaluate the expression. Return an integer that represents the value of the expression.\r\n\r\nNote that:\r\n\r\nThe valid operators are '+', '-', '*', and '/'.\r\nEach operand may be an integer or another expression.\r\nThe division between two integers always truncates toward zero.\r\nThere will not be any division by zero.\r\nThe input represents a valid arithmetic expression in a reverse polish notation.\r\nThe answer and all the intermediate calculations can be represented in a 32-bit integer.\r\n \r\n\r\nExample 1:\r\n\r\nInput: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\r\nOutput: 9\r\nExplanation: ((2 + 1) * 3) = 9\r\nExample 2:\r\n\r\nInput: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\r\nOutput: 6\r\nExplanation: (4 + (13 / 5)) = 6\r\nExample 3:\r\n\r\nInput: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\r\nOutput: 22\r\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\r\n= ((10 * (6 / (12 * -11))) + 17) + 5\r\n= ((10 * (6 / -132)) + 17) + 5\r\n= ((10 * 0) + 17) + 5\r\n= (0 + 17) + 5\r\n= 17 + 5\r\n= 22",
    "solution": "class Solution {\r\n    public int evalRPN(String[] tokens) {\r\n        Stack<Integer> st = new Stack<>();\r\n        int val = 0;\r\n        for(String s: tokens){\r\n            if(s.equals(\"*\") || s.equals(\"+\") || s.equals(\"-\") || s.equals(\"/\")){\r\n                int b = st.pop();\r\n                int a = st.pop();\r\n                int temp = cal(a,b,s);\r\n                System.out.println(temp);\r\n                st.push(temp);\r\n                val = temp;\r\n            }\r\n            else {\r\n                System.out.println(s);\r\n                st.push(Integer.parseInt(s));\r\n            }\r\n        }\r\n        return val;\r\n    }\r\n\r\n    public int cal(int a, int b, String s){\r\n        switch(s){\r\n            case \"+\" :  return a + b;\r\n            case \"*\" :  return a * b;\r\n            case \"-\" :  return a - b;\r\n            case \"/\" :  return a / b;\r\n        }\r\n        return 0;\r\n    }\r\n}"
  },
  {
    "id": "min-stack",
    "title": "Min Stack",
    "topic": "Stack",
    "difficulty": "Medium",
    "tags": "Stack",
    "statement": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\r\n\r\nImplement the MinStack class:\r\n\r\nMinStack() initializes the stack object.\r\nvoid push(int val) pushes the element val onto the stack.\r\nvoid pop() removes the element on the top of the stack.\r\nint top() gets the top element of the stack.\r\nint getMin() retrieves the minimum element in the stack.\r\nYou must implement a solution with O(1) time complexity for each function.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\r\n[[],[-2],[0],[-3],[],[],[],[]]\r\n\r\nOutput\r\n[null,null,null,null,-3,null,0,-2]\r\n\r\nExplanation\r\nMinStack minStack = new MinStack();\r\nminStack.push(-2);\r\nminStack.push(0);\r\nminStack.push(-3);\r\nminStack.getMin(); // return -3\r\nminStack.pop();\r\nminStack.top();    // return 0\r\nminStack.getMin(); // return -2",
    "solution": "class Node {\r\n    int val;\r\n    int min;\r\n\r\n    public String toString(){\r\n        return \"val: \"+val+\", min:\"+min;\r\n    }\r\n}\r\n\r\nclass MinStack {\r\n\r\n    Stack<Node> st = null;\r\n    public MinStack() {\r\n        st = new Stack<Node>();\r\n    }\r\n    \r\n    public void push(int val) {\r\n        Node n = new Node();\r\n        n.val = val;\r\n        if(st.isEmpty()){           \r\n            n.min = val;            \r\n        }\r\n        else{\r\n            Node temp = st.peek();\r\n            if(temp.min < val){\r\n                n.min = temp.min;\r\n            }\r\n            else{\r\n                n.min = val;\r\n            }\r\n        }\r\n        st.push(n);\r\n        //System.out.println(\"Push:\" +st.toString());\r\n    }\r\n    \r\n    public void pop() {\r\n        st.pop();\r\n        //System.out.println(\"Pop:\" +st.toString());\r\n    }\r\n    \r\n    public int top() {\r\n        Node n = st.peek();\r\n        return n.val;\r\n    }\r\n    \r\n    public int getMin() {\r\n        Node n = st.peek();\r\n        return n.min;\r\n    }\r\n}\r\n\r\n/**\r\n * Your MinStack object will be instantiated and called as such:\r\n * MinStack obj = new MinStack();\r\n * obj.push(val);\r\n * obj.pop();\r\n * int param_3 = obj.top();\r\n * int param_4 = obj.getMin();\r\n */"
  },
  {
    "id": "implement-stack-using-queue",
    "title": "Implment Stack Using Queue",
    "topic": "Stack",
    "difficulty": "Easy",
    "tags": "Stack",
    "statement": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\r\n\r\nImplement the MyStack class:\r\n\r\nvoid push(int x) Pushes element x to the top of the stack.\r\nint pop() Removes the element on the top of the stack and returns it.\r\nint top() Returns the element on the top of the stack.\r\nboolean empty() Returns true if the stack is empty, false otherwise.\r\nNotes:\r\n\r\nYou must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.\r\nDepending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\nOutput\r\n[null, null, null, 2, 2, false]\r\n\r\nExplanation\r\nMyStack myStack = new MyStack();\r\nmyStack.push(1);\r\nmyStack.push(2);\r\nmyStack.top(); // return 2\r\nmyStack.pop(); // return 2\r\nmyStack.empty(); // return False",
    "solution": "class MyStack {\r\n\r\n    private Queue<Integer> q1;\r\n    private Queue<Integer> q2;\r\n\r\n    public MyStack() {\r\n        q1 = new ArrayDeque<>();\r\n        q2 = new ArrayDeque<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        q1.add(x);\r\n    }\r\n\r\n    public int pop() {\r\n        while (q1.size() > 1) {\r\n            q2.add(q1.poll());\r\n        }\r\n\r\n        int poppedVal = q1.poll();\r\n        Queue<Integer> temp = q1;\r\n        q1 = q2;\r\n        q2 = temp;\r\n\r\n        return poppedVal;\r\n    }\r\n\r\n    public int top() {\r\n        while (q1.size() > 1) {\r\n            q2.add(q1.poll());\r\n        }\r\n\r\n        int topVal = q1.peek();\r\n        q2.add(q1.poll());\r\n        Queue<Integer> temp = q1;\r\n        q1 = q2;\r\n        q2 = temp;\r\n\r\n        return topVal;\r\n    }\r\n\r\n    public boolean empty() {\r\n        return q1.isEmpty();\r\n    }\r\n}"
  },
  {
    "id": "daily-temperatures",
    "title": "Daily Temperatures",
    "topic": "Stack",
    "difficulty": "Medium",
    "tags": "monotonic stack",
    "statement": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: temperatures = [73,74,75,71,69,72,76,73]\r\nOutput: [1,1,4,2,1,1,0,0]\r\nExample 2:\r\n\r\nInput: temperatures = [30,40,50,60]\r\nOutput: [1,1,1,0]\r\nExample 3:\r\n\r\nInput: temperatures = [30,60,90]\r\nOutput: [1,1,0]",
    "solution": "class Solution {\r\n    public int[] dailyTemperatures(int[] temperatures) {\r\n        int n = temperatures.length;\r\n        int[] output = new int[n];\r\n        Stack<Integer> st = new Stack<>();\r\n        for(int i=n-1;i>=0;i--){\r\n            while(!st.isEmpty() && temperatures[st.peek()] <= temperatures[i]){\r\n                st.pop();\r\n            }\r\n            if(st.isEmpty())\r\n                output[i] = 0;\r\n            else \r\n                output[i] = st.peek() - i;\r\n\r\n            st.push(i);\r\n        }\r\n\r\n        return output;\r\n    }\r\n}"
  },
  {
    "id": "asteroid-collision",
    "title": "Asteroid Collision",
    "topic": "Stack",
    "difficulty": "Medium",
    "tags": "",
    "statement": "We are given an array asteroids of integers representing asteroids in a row. The indices of the asteroid in the array represent their relative position in space.\r\n\r\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\r\n\r\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: asteroids = [5,10,-5]\r\nOutput: [5,10]\r\nExplanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\r\nExample 2:\r\n\r\nInput: asteroids = [8,-8]\r\nOutput: []\r\nExplanation: The 8 and -8 collide exploding each other.\r\nExample 3:\r\n\r\nInput: asteroids = [10,2,-5]\r\nOutput: [10]\r\nExplanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.\r\nExample 4:\r\n\r\nInput: asteroids = [3,5,-6,2,-1,4]​​​​​​​\r\nOutput: [-6,2,4]\r\nExplanation: The asteroid -6 makes the asteroid 3 and 5 explode, and then continues going left. On the other side, the asteroid 2 makes the asteroid -1 explode and then continues going right, without reaching asteroid 4.",
    "solution": "class Solution {\r\n    public int[] asteroidCollision(int[] asteroids) {\r\n        \r\n        int n = asteroids.length;\r\n        Stack<Integer> st = new Stack<>();\r\n        for(int i: asteroids){\r\n            if( i > 0){\r\n                st.push(i);\r\n            }\r\n            else {\r\n                while(!st.isEmpty() && st.peek() > 0 && i < 0 && st.peek() < Math.abs(i)){\r\n                    st.pop();\r\n                }\r\n\r\n                if(st.isEmpty() || st.peek() < 0){\r\n                    st.push(i);\r\n                }\r\n\r\n                if(!st.isEmpty() && st.peek() == -1 * i){\r\n                    st.pop();\r\n                }\r\n            }\r\n        \r\n        }\r\n\r\n        int[] out = new int[st.size()];\r\n            for(int i=st.size() -1;i>=0;i--){\r\n                out[i] = st.pop();\r\n            }\r\n\r\n            return out;\r\n\r\n        \r\n    }\r\n}"
  },
  {
    "id": "basic-calculator-2",
    "title": "Basic Calculator II",
    "topic": "Stack",
    "difficulty": "Medium",
    "tags": "",
    "statement": "Given a string s which represents an expression, evaluate this expression and return its value. \r\n\r\nThe integer division should truncate toward zero.\r\n\r\nYou may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].\r\n\r\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"3+2*2\"\r\nOutput: 7\r\nExample 2:\r\n\r\nInput: s = \" 3/2 \"\r\nOutput: 1\r\nExample 3:\r\n\r\nInput: s = \" 3+5 / 2 \"\r\nOutput: 5",
    "solution": "class Solution {\r\n    public int calculate(String s) {\r\n        Stack<Integer> num = new Stack<>();\r\n        Stack<Character> op = new Stack<>();\r\n        int number =0;\r\n        s = s.trim();\r\n        for(char c: s.toCharArray()){\r\n            if( c == ' ')\r\n                continue;\r\n            \r\n            if(Character.isDigit(c)){\r\n                number = number * 10 + Character.getNumericValue(c);\r\n            }\r\n            else {\r\n                System.out.println(c);\r\n                while (!op.isEmpty() && precedence(op.peek()) >= precedence(c)) {\r\n                    int b = number;\r\n                    int a = num.pop();\r\n                    number = eval(a, b, op.pop());\r\n                }\r\n                num.push(number);\r\n                number = 0;\r\n                op.push(c);\r\n            }\r\n\r\n            \r\n        }\r\n        // finalize\r\n        while (!op.isEmpty()) {\r\n            int b = number;\r\n            int a = num.pop();\r\n            number = eval(a, b, op.pop());\r\n        }\r\n\r\n        return number;\r\n    }\r\n\r\n    private int precedence(char c) {\r\n        if (c == '*' || c == '/') return 2;\r\n        return 1; // + or -\r\n    }\r\n\r\n\r\n    public int eval(int a, int b, char c){\r\n        System.out.println(\"(a,b) with c->\"+a+\",\"+b+\",\"+c);\r\n        switch(c){\r\n            case '+': return a+b;\r\n            case '-': return a-b;\r\n            case '*': return a*b;\r\n            case '/': return a/b;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n\r\n/**\r\nLoop \r\nifdigit \r\n    number = number + 10 * c;\r\n\r\n    ifoperator()\r\n        stack.push(number)\r\n        stack.push(operator)\r\n    \r\n    \r\n455*3424/455\r\n\r\n */"
  },
  {
    "id": "decode-string",
    "title": "Decode String",
    "topic": "Stack",
    "difficulty": "Medium",
    "tags": "",
    "statement": "Given an encoded string, return its decoded string.\r\n\r\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\r\n\r\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].\r\n\r\nThe test cases are generated so that the length of the output will never exceed 105.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"3[a]2[bc]\"\r\nOutput: \"aaabcbc\"\r\nExample 2:\r\n\r\nInput: s = \"3[a2[c]]\"\r\nOutput: \"accaccacc\"\r\nExample 3:\r\n\r\nInput: s = \"2[abc]3[cd]ef\"\r\nOutput: \"abcabccdcdcdef\"",
    "solution": "class Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Integer> n = new Stack<>();\r\n        Stack<StringBuilder> st = new Stack<>();\r\n        int num = 0;\r\n        StringBuilder currString = new StringBuilder();\r\n        for(char c: s.toCharArray()){\r\n            if(Character.isDigit(c)){\r\n                num = num * 10 + c - '0';\r\n            }\r\n            else if(c == '['){\r\n                n.push(num);\r\n                num =0;\r\n                st.push(currString);\r\n                currString = new StringBuilder();\r\n            }\r\n            else if(c == ']'){\r\n                int number = n.pop();    \r\n                StringBuilder prev = st.pop();\r\n                for(int i=0;i<number;i++){\r\n                    prev.append(currString);\r\n                }\r\n                currString = prev;          \r\n            }\r\n            else {\r\n                currString.append(c);\r\n            }\r\n        }\r\n\r\n        return currString.toString();\r\n    }\r\n}"
  },
  {
    "id": "trapping-rain-water",
    "title": "Trapping Rain Water",
    "topic": "Stack",
    "difficulty": "Hard",
    "tags": "",
    "statement": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\r\nOutput: 6\r\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\r\nExample 2:\r\n\r\nInput: height = [4,2,0,3,2,5]\r\nOutput: 9",
    "solution": "class Solution {\r\n    public int trap(int[] height) {\r\n\r\n        int n = height.length;\r\n        int[] prevBig = new int[n];\r\n        int[] nextBig = new int[n];\r\n        int max =0;\r\n        for(int i=0;i<n;i++){\r\n            prevBig[i] =  max;\r\n            max = Math.max(max,height[i]);\r\n        }\r\n\r\n        for(int i : prevBig){\r\n            System.out.print(i+\" \");\r\n        }\r\n        System.out.println();\r\n\r\n        max=0;\r\n        for(int i=n-1;i>=0;i--){\r\n            nextBig[i] = max;\r\n            max = Math.max(max,height[i]);\r\n        }\r\n\r\n        for(int i : nextBig){\r\n            System.out.print(i+\" \");\r\n        }\r\n\r\n        System.out.println();\r\n\r\n\r\n\r\n\r\n        int count =0;\r\n        \r\n        for(int i=0;i<n;i++){\r\n            int temp = Math.min(prevBig[i],nextBig[i]);\r\n            if( temp - height[i] > 0){\r\n                count = count + temp - height[i];\r\n            }\r\n        }\r\n        \r\n        return count;\r\n    }\r\n}\r\n\r\n// [0,0,1,1,2,2,2,2,3,3,3,3]\r\n// [3,3,3,3,3,3,3,2,2,2,1,0]\r\n\r\n// [0,1,0,2,1,0,1,3,2,1,2,1]\r\n\r\n// [0,0,1,0,1,2,1,0,0,1,0,0]"
  },
  {
    "id": "basic-calculator",
    "title": "Basic Calculator",
    "topic": "Stack",
    "difficulty": "Hard",
    "tags": "",
    "statement": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\r\n\r\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"1 + 1\"\r\nOutput: 2\r\nExample 2:\r\n\r\nInput: s = \" 2-1 + 2 \"\r\nOutput: 3\r\nExample 3:\r\n\r\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\r\nOutput: 23",
    "solution": "class Solution {\r\n    public int calculate(String s) {\r\n        Stack<Integer> st = new Stack<>();\r\n        int number =0, sign = 1, result = 0;\r\n\r\n        for(char c: s.toCharArray()){\r\n            if(Character.isDigit(c)){\r\n                number = number * 10 + (c - '0');\r\n            }\r\n            else if(c == '+'){\r\n                result = result + sign * number;\r\n                sign = 1;\r\n                number = 0;\r\n            }\r\n            else if(c == '-'){\r\n                result = result + sign * number;\r\n                sign = -1;\r\n                number = 0;\r\n            }\r\n            else if( c == '('){\r\n                st.push(result);\r\n                st.push(sign);\r\n                result = 0;\r\n                sign = 1;\r\n            }\r\n            else if( c == ')'){\r\n                result = result + sign * number;\r\n                number = 0;\r\n                result = result * st.pop();\r\n                result = result + st.pop();\r\n            }\r\n        }\r\n\r\n        if(number != 0){\r\n            result = result + sign * number;\r\n        }\r\n\r\n        return result;\r\n    }\r\n}"
  },
  {
    "id": "longest-valid-paranthesis",
    "title": "Longest Valid Parentheses",
    "topic": "Stack",
    "difficulty": "Hard",
    "tags": "",
    "statement": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"(()\"\r\nOutput: 2\r\nExplanation: The longest valid parentheses substring is \"()\".\r\nExample 2:\r\n\r\nInput: s = \")()())\"\r\nOutput: 4\r\nExplanation: The longest valid parentheses substring is \"()()\".\r\nExample 3:\r\n\r\nInput: s = \"\"\r\nOutput: 0",
    "solution": "class Solution {\r\n    public int longestValidParentheses(String s) {\r\n        Stack<Integer> st = new Stack<>();\r\n        st.push(-1);\r\n        int maxLength = 0;\r\n        for(int i=0;i<s.length();i++){\r\n            char c = s.charAt(i);\r\n            if(c == '('){\r\n                st.push(i);\r\n            }\r\n            else {\r\n                st.pop();\r\n                if(st.isEmpty()){\r\n                    st.push(i);\r\n                }\r\n                else {\r\n                    maxLength = Math.max(maxLength, i - st.peek());\r\n                }\r\n            }\r\n        }\r\n\r\n        return maxLength;\r\n\r\n    }\r\n}"
  },
  {
    "id": "maximum-frequency-stack",
    "title": "Maximum Frequency Stack",
    "topic": "Stack",
    "difficulty": "Hard",
    "tags": "Heap,LFU",
    "statement": "Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\r\n\r\nImplement the FreqStack class:\r\n\r\nFreqStack() constructs an empty frequency stack.\r\nvoid push(int val) pushes an integer val onto the top of the stack.\r\nint pop() removes and returns the most frequent element in the stack.\r\nIf there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\r\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\r\nOutput\r\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\r\n\r\nExplanation\r\nFreqStack freqStack = new FreqStack();\r\nfreqStack.push(5); // The stack is [5]\r\nfreqStack.push(7); // The stack is [5,7]\r\nfreqStack.push(5); // The stack is [5,7,5]\r\nfreqStack.push(7); // The stack is [5,7,5,7]\r\nfreqStack.push(4); // The stack is [5,7,5,7,4]\r\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\r\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\r\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\r\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\r\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].",
    "solution": "class FreqStack {\r\n    HashMap<Integer,LinkedList<Integer>> st;\r\n    HashMap<Integer,Integer> map;\r\n    int maxFreq=0; \r\n\r\n    public FreqStack() {\r\n        st = new HashMap<Integer,LinkedList<Integer>>();\r\n        map = new HashMap<Integer,Integer>();\r\n        maxFreq=0;\r\n    }\r\n    \r\n    public void push(int val) {\r\n        int curr = map.getOrDefault(val,0);\r\n        curr++;\r\n        map.put(val,curr);\r\n        if(!st.containsKey(curr)){\r\n            st.put(curr, new LinkedList<Integer>());\r\n        }\r\n        st.get(curr).addFirst(val);\r\n        maxFreq = Math.max(maxFreq,curr);\r\n    }\r\n    \r\n    public int pop() {\r\n        int ans = st.get(maxFreq).removeFirst();\r\n\r\n        int currFreq = map.get(ans);\r\n        currFreq--;\r\n        map.put(ans,currFreq);\r\n        if(st.get(maxFreq).size() == 0){\r\n            maxFreq--;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n/**\r\n * Your FreqStack object will be instantiated and called as such:\r\n * FreqStack obj = new FreqStack();\r\n * obj.push(val);\r\n * int param_2 = obj.pop();\r\n */"
  },
  {
    "id": "largest-rectangle-histogram",
    "title": "Largest Rectangle in Histogram",
    "topic": "Stack",
    "difficulty": "Hard",
    "tags": "monotonic stack",
    "statement": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: heights = [2,1,5,6,2,3]\r\nOutput: 10\r\nExplanation: The above is a histogram where width of each bar is 1.\r\nThe largest rectangle is shown in the red area, which has an area = 10 units.\r\nExample 2:\r\n\r\n\r\nInput: heights = [2,4]\r\nOutput: 4\r\n ",
    "solution": "class Solution {\r\n    public int largestRectangleArea(int[] heights) {\r\n        Stack<Integer> st = new Stack<>();\r\n        int max=0;\r\n        for(int i=0;i<heights.length;i++){\r\n            int currValue = heights[i];\r\n\r\n            while(!st.isEmpty() && heights[st.peek()] >= currValue){\r\n\r\n                // now find area for current index. \r\n                int index = st.pop();\r\n                int nextSmallerElementIndex = i;\r\n                int previousSmllerElementIndex = st.isEmpty() ? -1 : st.peek();\r\n                int currArea = heights[index] * (nextSmallerElementIndex - previousSmllerElementIndex - 1);\r\n                max = Math.max(max,currArea);\r\n            }\r\n\r\n            st.push(i);\r\n        }\r\n        // the next smaller element index is N since we have reached the end of array\r\n        int nextSmallerElementIndex = heights.length;\r\n        while(!st.isEmpty()){\r\n            int currInd = st.pop();\r\n            int preSmllerElementIndex = st.isEmpty() ? -1 : st.peek();\r\n            max = Math.max(max,heights[currInd] * (nextSmallerElementIndex - preSmllerElementIndex - 1));\r\n        }\r\n\r\n        return max;\r\n    }\r\n}"
  },
  {
    "id": "merge-two-sorted-lists",
    "title": "Merge Two Sorted Lists",
    "topic": "LinkedList",
    "difficulty": "Easy",
    "tags": "",
    "statement": "You are given the heads of two sorted linked lists list1 and list2.\r\n\r\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\r\n\r\nReturn the head of the merged linked list.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: list1 = [1,2,4], list2 = [1,3,4]\r\nOutput: [1,1,2,3,4,4]\r\nExample 2:\r\n\r\nInput: list1 = [], list2 = []\r\nOutput: []\r\nExample 3:\r\n\r\nInput: list1 = [], list2 = [0]\r\nOutput: [0]",
    "solution": "\r\n\r\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\r\n        ListNode prehead = new ListNode(-1);\r\n        ListNode cur = prehead;\r\n\r\n        while (l1 != null && l2 != null) {\r\n            if (l1.val <= l2.val) {\r\n                cur.next = l1;\r\n                l1 = l1.next;\r\n            } else {\r\n                cur.next = l2;\r\n                l2 = l2.next;\r\n            }\r\n            cur = cur.next;\r\n        }\r\n\r\n        cur.next = l1 == null ? l2 : l1;\r\n        return prehead.next;\r\n    }"
  },
  {
    "id": "reverse-linked-list",
    "title": "Reverse Linked List",
    "topic": "LinkedList",
    "difficulty": "Easy",
    "tags": "",
    "statement": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "solution": "/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode reverseList(ListNode head) {\r\n        ListNode next=null;\r\n        ListNode curr= head;\r\n        ListNode prev= null;\r\n        while(curr!=null){\r\n            next = curr.next;\r\n            curr.next = prev;\r\n            prev =  curr;\r\n            curr = next;\r\n        }\r\n        \r\n        return prev;\r\n        \r\n    }\r\n}"
  },
  {
    "id": "swap-nodes-in-pairs",
    "title": "Swap Nodes in Pairs",
    "topic": "LinkedList",
    "difficulty": "Medium",
    "tags": "",
    "statement": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: head = [1,2,3,4]\r\n\r\nOutput: [2,1,4,3]\r\n\r\nExplanation:\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: head = []\r\n\r\nOutput: []\r\n\r\nExample 3:\r\n\r\nInput: head = [1]\r\n\r\nOutput: [1]\r\n\r\nExample 4:\r\n\r\nInput: head = [1,2,3]\r\n\r\nOutput: [2,1,3]",
    "solution": "/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        \r\n        ListNode temp = head, prev = null;\r\n\r\n        while(temp != null && temp.next != null){\r\n            ListNode first = temp;\r\n            ListNode second = temp.next;\r\n            ListNode next = second.next;\r\n\r\n            second.next = first;\r\n            first.next = next;\r\n\r\n            if(prev != null){\r\n                prev.next = second;\r\n            }\r\n            else{\r\n                head = second;\r\n            }\r\n            prev = first;\r\n            temp = first.next;\r\n        }\r\n\r\n        return head;\r\n    }\r\n}"
  },
  {
    "id": "Reorder-list",
    "title": "Reorder List",
    "topic": "LinkedList",
    "difficulty": "Medium",
    "tags": "",
    "statement": "You are given the head of a singly linked-list. The list can be represented as:\r\n\r\nL0 → L1 → … → Ln - 1 → Ln\r\nReorder the list to be on the following form:\r\n\r\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …\r\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.",
    "solution": "/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public void reorderList(ListNode head) {\r\n     int count = 0;\r\n     ListNode temp = head;\r\n     Stack<Integer> st = new Stack<>();\r\n     while(temp != null){\r\n        st.push(temp.val);\r\n        temp = temp.next;\r\n        count++;\r\n     }\r\n\r\n    temp = head;\r\n\r\n    while(temp != null && st.size() > 0){\r\n        ListNode next = temp.next;\r\n        ListNode newNode = new ListNode(st.pop());\r\n        temp.next = newNode;\r\n        newNode.next = next;\r\n        temp = temp.next.next;\r\n    }\r\n\r\n    temp = head;\r\n\r\n    while(count>1){\r\n        temp = temp.next;\r\n        count--;\r\n    }\r\n    temp.next = null;\r\n\r\n\r\n    }\r\n}"
  },
  {
    "id": "find-duplicate-number",
    "title": "Find the Duplicate Number",
    "topic": "LinkedList",
    "difficulty": "Medium",
    "tags": "Negative Marking",
    "statement": "You are given an array of integers nums containing n + 1 integers. Each integer in nums is in the range [1, n] inclusive.\r\n\r\nEvery integer appears exactly once, except for one integer which appears two or more times. Return the integer that appears more than once.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,2,2]\r\n\r\nOutput: 2\r\nExample 2:\r\n\r\nInput: nums = [1,2,3,4,4]\r\n\r\nOutput: 4\r\nFollow-up: Can you solve the problem without modifying the array nums and using \r\nO\r\n(\r\n1\r\n)\r\nO(1) extra space?",
    "solution": "public class Solution {\r\n    public int findDuplicate(int[] nums) {\r\n        for (int num : nums) {\r\n            int idx = Math.abs(num) - 1;\r\n            if (nums[idx] < 0) {\r\n                return Math.abs(num);\r\n            }\r\n            nums[idx] *= -1;\r\n        }\r\n        return -1;\r\n    }\r\n}"
  },
  {
    "id": "lru-cache",
    "title": "LRU Cache",
    "topic": "LinkedList",
    "difficulty": "Hard",
    "tags": "Double LinkedList + Map",
    "statement": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\r\n\r\nImplement the LRUCache class:\r\n\r\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\r\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\r\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\r\nThe functions get and put must each run in O(1) average time complexity.",
    "solution": "class Node {\r\n    int key;\r\n    int value;\r\n    Node prev;\r\n    Node next;\r\n\r\n    public Node(int key, int value){\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n\r\n    public String toString(){\r\n        return key+\",\"+value;\r\n    }\r\n}\r\n\r\nclass LRUCache {\r\n    HashMap<Integer,Node> cache;\r\n    int capacity = 0;\r\n    Node head;\r\n    Node tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        this.cache = new HashMap<Integer,Node>();\r\n        this.head = new Node(-1,-1);\r\n        this.tail = new Node(-1,-1);\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(!cache.containsKey(key)){\r\n            return -1;\r\n        }\r\n\r\n        Node n = cache.get(key);\r\n        removeNode(n);\r\n        addNode(n);\r\n        return n.value;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(cache.containsKey(key)){\r\n            // if  element exist, remove the node for doubly linkedlist\r\n            Node entry = cache.get(key);\r\n            removeNode(entry);\r\n        }\r\n        Node newEntry = new Node(key,value);\r\n        cache.put(key,newEntry);\r\n        addNode(newEntry);\r\n\r\n        if(cache.size() > capacity){\r\n            Node deleteCache = tail.prev;\r\n            cache.remove(deleteCache.key);\r\n            removeNode(deleteCache);\r\n        }\r\n    }\r\n\r\n    public void addNode(Node node){\r\n        Node next = head.next;\r\n        head.next = node;\r\n        node.next = next;\r\n        next.prev = node;\r\n        node.prev = head;\r\n    }\r\n\r\n    public void removeNode(Node node){\r\n        Node next = node.next;\r\n        Node prev = node.prev;\r\n        prev.next = next;\r\n        next.prev = prev;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */"
  },
  {
    "id": "merge-k-sorted-lists",
    "title": "Merge K Sorted Linked Lists",
    "topic": "LinkedList",
    "difficulty": "Hard",
    "tags": "",
    "statement": "You are given an array of k linked lists lists, where each list is sorted in ascending order.\r\n\r\nReturn the sorted linked list that is the result of merging all of the individual linked lists.\r\n\r\nExample 1:\r\n\r\nInput: lists = [[1,2,4],[1,3,5],[3,6]]\r\n\r\nOutput: [1,1,2,3,3,4,5,6]\r\nExample 2:\r\n\r\nInput: lists = []\r\n\r\nOutput: []\r\nExample 3:\r\n\r\nInput: lists = [[]]\r\n\r\nOutput: []",
    "solution": "class Solution {\r\n    public ListNode mergeKLists(ListNode[] lists) {\r\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\r\n\r\n        for(ListNode n: lists){\r\n            while(n != null){\r\n                pq.add(n.val);\r\n                n = n.next;\r\n            }\r\n        }\r\n\r\n        ListNode head = new ListNode(-1);\r\n        ListNode temp = head;\r\n        while(!pq.isEmpty()){\r\n            ListNode node = new ListNode(pq.poll());\r\n            temp.next = node;\r\n            temp = temp.next; \r\n        }\r\n\r\n        return head.next;\r\n    }\r\n}"
  },
  {
    "id": "reverse-nodes-in-k-groups",
    "title": "Reverse Nodes in k-Group",
    "topic": "LinkedList",
    "difficulty": "Hard",
    "tags": "",
    "statement": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\r\n\r\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\r\n\r\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [1,2,3,4,5], k = 2\r\nOutput: [2,1,4,3,5]\r\nExample 2:\r\n\r\n\r\nInput: head = [1,2,3,4,5], k = 3\r\nOutput: [3,2,1,4,5]",
    "solution": "class Solution {\r\n    public ListNode reverseKGroup(ListNode head, int k) {\r\n        int n =0;\r\n        ListNode temp = head;\r\n        while(temp != null){\r\n            temp = temp.next;\r\n            n++;\r\n        }\r\n\r\n        if(k > n){\r\n            return head;\r\n        }\r\n\r\n        int t = n / k;\r\n\r\n        ListNode dummy = new ListNode(-1);\r\n        dummy.next = head;\r\n        ListNode prevGroup = dummy;\r\n\r\n        while(t>0){\r\n            // first node of the group\r\n            ListNode start = prevGroup.next;\r\n            ListNode curr = start;\r\n            ListNode prev = null;\r\n            ListNode next = null;\r\n            int count = k;\r\n            while (count > 0){\r\n                next = curr.next;\r\n                curr.next = prev;\r\n                prev = curr;\r\n                curr = next;\r\n                count--;\r\n            }\r\n\r\n            prevGroup.next = prev;\r\n            start.next = curr;\r\n            prevGroup = start;\r\n            t--;\r\n        }\r\n\r\n        return dummy.next;\r\n    }\r\n}"
  },
  {
    "id": "flood-fill",
    "title": "Flood Fill",
    "topic": "Graph",
    "difficulty": "Easy",
    "tags": "DFS/BFS",
    "statement": "You are given an image represented by an m x n grid of integers image, where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and color. Your task is to perform a flood fill on the image starting from the pixel image[sr][sc].\r\n\r\nTo perform a flood fill:\r\n\r\nBegin with the starting pixel and change its color to color.\r\nPerform the same process for each pixel that is directly adjacent (pixels that share a side with the original pixel, either horizontally or vertically) and shares the same color as the starting pixel.\r\nKeep repeating this process by checking neighboring pixels of the updated pixels and modifying their color if it matches the original color of the starting pixel.\r\nThe process stops when there are no more adjacent pixels of the original color to update.\r\nReturn the modified image after performing the flood fill.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\r\n\r\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\r\n\r\nExplanation:\r\n\r\n\r\n\r\nFrom the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\r\n\r\nNote the bottom corner is not colored 2, because it is not horizontally or vertically connected to the starting pixel.\r\n\r\nExample 2:\r\n\r\nInput: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\r\n\r\nOutput: [[0,0,0],[0,0,0]]\r\n\r\nExplanation:\r\n\r\nThe starting pixel is already colored with 0, which is the same as the target color. Therefore, no changes are made to the image.",
    "solution": "class Solution {\r\n    int[][] visited = null;\r\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\r\n\r\n        int m = image.length;\r\n        int n = image[0].length;\r\n\r\n        visited = new int[m][n];\r\n\r\n        fill(image,sr,sc,color,image[sr][sc]);\r\n\r\n        return image;\r\n    }\r\n\r\n\r\n    public void fill(int[][] image, int sr, int sc, int color, int oldcolor){\r\n        int m = image.length;\r\n        int n = image[0].length;\r\n\r\n        if(sr < 0 || sr >= m || sc < 0 || sc >= n)\r\n            return;\r\n        \r\n        if(image[sr][sc] != oldcolor || visited[sr][sc] == 1){\r\n            return;\r\n        }\r\n\r\n        image[sr][sc] = color;\r\n        visited[sr][sc] = 1;\r\n\r\n        fill(image,sr+1,sc,color,oldcolor);\r\n        fill(image,sr,sc+1,color,oldcolor);\r\n        fill(image,sr-1,sc,color,oldcolor);\r\n        fill(image,sr,sc-1,color,oldcolor);\r\n\r\n        return;\r\n\r\n    } \r\n}"
  },
  {
    "id": "01-matrix",
    "title": "01 Matrix",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "DFS/BFS",
    "statement": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\r\n\r\nThe distance between two cells sharing a common edge is 1.",
    "solution": "class Solution {\r\n    public int[][] updateMatrix(int[][] mat) {\r\n        \r\n        int n = mat.length;\r\n        int m = mat[0].length;\r\n        int[][] visited = new int[n][m];\r\n\r\n        Queue<int[]> q = new LinkedList<>();\r\n\r\n        for(int i=0;i<n;i++){\r\n            for(int j=0;j<m;j++){\r\n                if(mat[i][j] == 0){\r\n                    q.add(new int[]{i,j,0});\r\n                    visited[i][j] = 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        int[] row = {-1,0,1,0};\r\n        int[] col = {0,1,0,-1};\r\n\r\n        while(!q.isEmpty()){\r\n            int[] curr = q.poll();\r\n\r\n            for(int i=0;i<4;i++){\r\n                int r = row[i] + curr[0];\r\n                int c = col[i] + curr[1];\r\n\r\n                if( r>=0 && r < n && c >=0 && c < m && visited[r][c] != 1){\r\n                    visited[r][c] = 1;\r\n                    mat[r][c] = curr[2] + 1;\r\n                    q.add(new int[]{r,c,mat[r][c]});\r\n                }\r\n            }\r\n        }\r\n\r\n        return mat;\r\n        \r\n    }\r\n}"
  },
  {
    "id": "clone-graph",
    "title": "Clone Graph",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "DFS/BFS",
    "statement": "Given a reference of a node in a connected undirected graph.\r\n\r\nReturn a deep copy (clone) of the graph.\r\n\r\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\r\n\r\nclass Node {\r\n    public int val;\r\n    public List<Node> neighbors;\r\n}\r\n \r\n\r\nTest case format:\r\n\r\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\r\n\r\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\r\n\r\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.",
    "solution": "class Solution {\r\n    HashMap<Node,Node> hashmap = new HashMap<>();\r\n\r\n    public Node cloneGraph(Node node) {\r\n        if(node == null)\r\n            return null;\r\n\r\n        if(hashmap.containsKey(node)){\r\n            return hashmap.get(node);\r\n        }\r\n\r\n        Node copy = new Node(node.val);\r\n        hashmap.put(node,copy);\r\n\r\n        for(Node n: node.neighbors){\r\n            copy.neighbors.add(cloneGraph(n));\r\n        }\r\n\r\n        return copy;\r\n\r\n    }\r\n}"
  },
  {
    "id": "course-schedule",
    "title": "Course Schedule",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "Topo Sort",
    "statement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\r\n\r\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\r\nReturn true if you can finish all courses. Otherwise, return false.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: numCourses = 2, prerequisites = [[1,0]]\r\nOutput: true\r\nExplanation: There are a total of 2 courses to take. \r\nTo take course 1 you should have finished course 0. So it is possible.\r\nExample 2:\r\n\r\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\r\nOutput: false\r\nExplanation: There are a total of 2 courses to take. \r\nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.",
    "solution": "class Solution {\r\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\r\n        List<List<Integer>> adjlist = new ArrayList<>();\r\n        for(int i=0;i<numCourses;i++){\r\n            adjlist.add(new ArrayList<Integer>());\r\n        }\r\n        // in degree \r\n        int[] indegree = new int[numCourses];\r\n        \r\n        for(int[] c: prerequisites){\r\n            adjlist.get(c[1]).add(c[0]);\r\n            indegree[c[0]]++;\r\n        }\r\n\r\n        Queue<Integer> q = new LinkedList<>();\r\n\r\n        for(int i=0;i<numCourses;i++){\r\n            if(indegree[i] == 0)\r\n            {\r\n                q.add(i);\r\n            }\r\n        }\r\n\r\n        int count =0;\r\n        while(!q.isEmpty()){\r\n            int curr = q.poll();\r\n            count++;\r\n\r\n            for(int i: adjlist.get(curr)){\r\n                indegree[i]--;\r\n\r\n                if(indegree[i] == 0){\r\n                    q.add(i);\r\n                }\r\n            }\r\n        }\r\n\r\n        return count == numCourses;\r\n\r\n    }\r\n}"
  },
  {
    "id": "course-schedule-2",
    "title": "Course Schedule II",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "Topo Sort",
    "statement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\r\n\r\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\r\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.",
    "solution": "class Solution {\r\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\r\n        List<List<Integer>> adjlist = new ArrayList<>();\r\n        for(int i=0;i<numCourses;i++){\r\n            adjlist.add(new ArrayList<Integer>());\r\n        }\r\n        // in degree \r\n        int[] indegree = new int[numCourses];\r\n        \r\n        for(int[] c: prerequisites){\r\n            adjlist.get(c[1]).add(c[0]);\r\n            indegree[c[0]]++;\r\n        }\r\n\r\n        Queue<Integer> q = new LinkedList<>();\r\n\r\n        for(int i=0;i<numCourses;i++){\r\n            if(indegree[i] == 0)\r\n            {\r\n                q.add(i);\r\n            }\r\n        }\r\n\r\n        int count =0;\r\n        int[] output = new int[numCourses];\r\n        while(!q.isEmpty()){\r\n            int curr = q.poll();\r\n            output[count] = curr;\r\n            count++;\r\n            for(int i: adjlist.get(curr)){\r\n                indegree[i]--;\r\n\r\n                if(indegree[i] == 0){\r\n                    q.add(i);\r\n                }\r\n            }\r\n        }\r\n\r\n        return count == numCourses ? output : new int[]{};\r\n\r\n    }\r\n}"
  },
  {
    "id": "number-of-islands",
    "title": "Number of Islands",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "DFS/BFS",
    "statement": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\r\n\r\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: grid = [\r\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\r\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\r\n]\r\nOutput: 1\r\nExample 2:\r\n\r\nInput: grid = [\r\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\r\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\r\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\r\n]\r\nOutput: 3\r\n ",
    "solution": "class Solution {\r\n    public int numIslands(char[][] grid) {\r\n        int n= grid.length;\r\n        int m = grid[0].length;\r\n\r\n        boolean[][] v = new boolean[n][m];\r\n        int count =0;\r\n        for(int i=0;i<n;i++){\r\n            for(int j=0;j<m;j++){\r\n                if(grid[i][j] == '1' && !v[i][j]){\r\n                    dfs(grid,v,n,m,i,j);\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    public void dfs(char[][] grid, boolean[][] visited, int n, int m, int i, int j){\r\n        if(i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != '1'){\r\n            return;\r\n        }\r\n\r\n        if(visited[i][j] == true)\r\n            return;\r\n        \r\n        visited[i][j] = true;\r\n\r\n        dfs(grid,visited,n,m,i-1,j);\r\n        dfs(grid,visited,n,m,i,j+1);\r\n        dfs(grid,visited,n,m,i+1,j);\r\n        dfs(grid,visited,n,m,i,j-1);\r\n    }\r\n}"
  },
  {
    "id": "rotting-oranges",
    "title": "Rotting Oranges",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "Multi Source BFS",
    "statement": "You are given an m x n grid where each cell can have one of three values:\r\n\r\n0 representing an empty cell,\r\n1 representing a fresh orange, or\r\n2 representing a rotten orange.\r\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\r\n\r\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.",
    "solution": "class Solution {\r\n    public int orangesRotting(int[][] grid) {\r\n        int n = grid.length, m = grid[0].length;\r\n        boolean[][] visited = new boolean[n][m];\r\n        int freshOrangePresent = 0;\r\n        Queue<int[]> queue = new LinkedList<>();\r\n\r\n        for(int i=0;i<n;i++){\r\n            for(int j=0;j<m;j++){\r\n                if(grid[i][j] == 2){\r\n                    queue.add(new int[]{i,j});\r\n                    visited[i][j] = true;\r\n                }\r\n                else if(grid[i][j] == 1){\r\n                    freshOrangePresent = 1;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // No rotten oranges\r\n        if(queue.isEmpty())\r\n            return freshOrangePresent == 1 ? -1 : 0;\r\n        \r\n        int[] row = {0,1,0,-1};\r\n        int[] col = {1,0,-1,0};\r\n        int count = 0;\r\n        while(!queue.isEmpty()){\r\n            int size = queue.size();            \r\n            \r\n            for(int k=0;k<size;k++){\r\n                int[] curr = queue.peek();\r\n                queue.remove();\r\n                for(int i=0;i<4;i++){\r\n                    int r = curr[0] + row[i];\r\n                    int c = curr[1] + col[i];\r\n                    if(r >= 0 && r < n && c >=0 && c < m && visited[r][c] == false && grid[r][c] == 1){\r\n                        grid[r][c] = 2;\r\n                        visited[r][c] = true;\r\n                        queue.add(new int[]{r,c});\r\n                    }\r\n                }\r\n                \r\n            }\r\n            count++;\r\n        }\r\n\r\n        for(int i=0;i<n;i++){\r\n            for(int j=0;j<m;j++){\r\n                if(grid[i][j] == 1)\r\n                    return -1;\r\n            }\r\n        }\r\n\r\n        return count - 1;\r\n    }\r\n}"
  },
  {
    "id": "word-search",
    "title": "Word Search",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "DFS/BFS",
    "statement": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\r\n\r\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\r\nOutput: true\r\nExample 2:\r\n\r\n\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\r\nOutput: true\r\nExample 3:\r\n\r\n\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\r\nOutput: false",
    "solution": "class Solution {\r\n    public boolean exist(char[][] board, String word) {\r\n        int n = board.length;\r\n        int m = board[0].length;\r\n        boolean[][] v = new boolean[n][m];\r\n        for(int i=0;i<n;i++){\r\n            for(int j=0;j<m;j++){\r\n                if(word.charAt(0) == board[i][j]){\r\n                    if(dfs(board,v,word,0,n,m,i,j)){\r\n                        return true;\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public boolean dfs(char[][] b, boolean[][] v, String word, int index, int n, int m, int i, int j){\r\n        if(i < 0 || j < 0 || i >= n || j >= m || v[i][j] || word.charAt(index) != b[i][j]){\r\n            return false;\r\n        }\r\n\r\n        if(index == word.length() - 1){\r\n            return true;\r\n        }\r\n\r\n        v[i][j] = true;\r\n        \r\n        boolean found = dfs(b,v,word,index+1,n,m,i-1,j) || dfs(b,v,word,index+1,n,m,i,j+1) || dfs(b,v,word,index+1,n,m,i+1,j) || dfs(b,v,word,index+1,n,m,i,j-1); \r\n\r\n        v[i][j] = false;\r\n        return found;\r\n    }\r\n}"
  },
  {
    "id": "accounts-merge",
    "title": "Accounts Merge",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "UnionFind/DisjointSet",
    "statement": "Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\r\n\r\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\r\n\r\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\r\nOutput: [[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\r\nExplanation:\r\nThe first and second John's are the same person as they have the common email \"johnsmith@mail.com\".\r\nThe third John and Mary are different people as none of their email addresses are used by other accounts.\r\nWe could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], \r\n['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.\r\nExample 2:\r\n\r\nInput: accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\r\nOutput: [[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
    "solution": "class UnionFind {\r\n    int[] parent;\r\n    int[] size;\r\n\r\n    public UnionFind(int n){\r\n        parent = new int[n];\r\n        size = new int[n];\r\n        for(int i=0;i<n;i++){\r\n            parent[i] = i;\r\n            size[i] = 1;\r\n        }\r\n    }\r\n\r\n    public int findParent(int n){\r\n        if(parent[n] == n)\r\n            return n;\r\n        parent[n] = findParent(parent[n]);\r\n        return parent[n];\r\n    }\r\n\r\n    public void union(int a, int b){\r\n        int parentA = findParent(a);\r\n        int parentB = findParent(b);\r\n\r\n        if(size[parentA] > size[parentB]){\r\n            parent[parentB] = parentA;\r\n            size[parentA] = size[parentB] + size[parentA];\r\n        }\r\n        else{\r\n\r\n            parent[parentA] = parentB;\r\n            size[parentB] = size[parentB] + size[parentA];\r\n\r\n        }\r\n    }\r\n}\r\n\r\nclass Solution {\r\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\r\n        int n = accounts.size();\r\n\r\n        UnionFind uf = new UnionFind(n);\r\n\r\n        HashMap<String,Integer> emaildsToNameId = new HashMap<>();\r\n\r\n\r\n        // here we are creating map of emails to user (represented at user index) \r\n        // Also, if email already exist that means same person, so we are doing union for it.\r\n        for(int i=0;i<n;i++){\r\n            List<String> emails= accounts.get(i);\r\n            // first index is name and rest is email\r\n            for(int j=1;j<emails.size();j++){\r\n                String email = emails.get(j);\r\n\r\n                if(emaildsToNameId.containsKey(email)){\r\n                    uf.union(i,emaildsToNameId.get(email));\r\n                }\r\n                else {\r\n                    emaildsToNameId.put(email,i);\r\n                }\r\n            }\r\n        }\r\n\r\n        HashMap<Integer,List<String>> idsToEmail = new HashMap<>();\r\n\r\n        for(String key: emaildsToNameId.keySet()){\r\n            int parent = uf.findParent(emaildsToNameId.get(key));\r\n            \r\n            if(idsToEmail.containsKey(parent)){\r\n                idsToEmail.get(parent).add(key);\r\n            }\r\n            else {\r\n                List<String> em = new ArrayList<>();\r\n                em.add(key);\r\n                idsToEmail.put(parent,em);\r\n            }\r\n        }\r\n\r\n        List<List<String>> output = new ArrayList<>();\r\n\r\n        for(int key: idsToEmail.keySet()){\r\n            List<String> list = idsToEmail.get(key);\r\n            Collections.sort(list);\r\n            list.add(0,accounts.get(key).get(0));\r\n            output.add(list);\r\n        }\r\n\r\n        return output;\r\n\r\n    }\r\n}"
  },
  {
    "id": "pacific-atlantic-water-flow",
    "title": "Pacific Atlantic Water Flow",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "DFS/BFS",
    "statement": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\r\n\r\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\r\n\r\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\r\n\r\nReturn a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.",
    "solution": "class Solution {\r\n     int dirs[][] = {{-1,0},{1,0},{0,1},{0,-1}};\r\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\r\n        int n = heights.length;\r\n        int m = heights[0].length;\r\n\r\n        List<List<Integer>> out = new ArrayList<>();\r\n\r\n        boolean[][] pac = new boolean[n][m];\r\n        boolean[][] atl = new boolean[n][m];\r\n\r\n        // do bfs for both pacific and atlantic\r\n        for(int i=0;i<m;i++){\r\n            bfs(0,i,pac,n,m,heights);\r\n            bfs(n-1,i,atl,n,m,heights);\r\n        }\r\n\r\n        for(int i=0;i<n;i++){\r\n            bfs(i,0,pac,n,m,heights);\r\n            bfs(i,m-1,atl,n,m,heights);\r\n        }\r\n\r\n        for(int i=0;i<n;i++){\r\n            for(int j=0;j<m;j++){\r\n                if(atl[i][j] && pac[i][j]){\r\n                    List<Integer> li = new ArrayList<>();\r\n                    li.add(i);\r\n                    li.add(j);\r\n                    out.add(li);\r\n                }\r\n            }\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    public void bfs(int x, int y, boolean[][] vis, int n, int m, int[][] heights){\r\n        Queue<int[]> q = new LinkedList<>();\r\n        q.add(new int[]{x,y});\r\n        vis[x][y] = true;\r\n\r\n        while(!q.isEmpty()){\r\n            int[] c = q.poll();\r\n\r\n            for(int[] d: dirs){\r\n                int nx = d[0] + c[0];\r\n                int ny = d[1] + c[1];\r\n                if(nx >= 0 && ny >= 0 && nx < n && ny < m && !vis[nx][ny] && heights[nx][ny] >= heights[c[0]][c[1]]){\r\n                    vis[nx][ny] = true;\r\n                    q.add(new int[]{nx,ny});\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n}"
  },
  {
    "id": "number-of-connected-components-undirected-graph",
    "title": "Number of Connected Components in an Undirected Graph\r\nSolved ",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "DFS/BFS",
    "statement": "There is an undirected graph with n nodes. There is also an edges array, where edges[i] = [a, b] means that there is an edge between node a and node b in the graph.\r\n\r\nThe nodes are numbered from 0 to n - 1.\r\n\r\nReturn the total number of connected components in that graph.\r\n\r\nExample 1:\r\n\r\nInput:\r\nn=3\r\nedges=[[0,1], [0,2]]\r\n\r\nOutput:\r\n1\r\nExample 2:\r\n\r\nInput:\r\nn=6\r\nedges=[[0,1], [1,2], [2,3], [4,5]]\r\n\r\nOutput:\r\n2",
    "solution": "class Solution {\r\n    public int countComponents(int n, int[][] edges) {\r\n        List<List<Integer>> adj = new ArrayList<>();\r\n        for(int i=0;i<n;i++){\r\n            adj.add(new ArrayList<>());\r\n        }\r\n        for(int[] edge: edges){\r\n            adj.get(edge[0]).add(edge[1]);\r\n            adj.get(edge[1]).add(edge[0]);\r\n        }\r\n\r\n        HashSet<Integer> visited = new HashSet<>();\r\n        int count =0;\r\n\r\n        for(int i=0;i<n;i++){\r\n            if(!visited.contains(i)){\r\n                System.out.println(i);\r\n                count++;\r\n                bfs(adj,visited,i);\r\n            }\r\n\r\n        }\r\n        return count;\r\n\r\n    }\r\n\r\n    public void bfs(List<List<Integer>> adj, HashSet<Integer> vis, int node){\r\n \r\n        vis.add(node);\r\n        for(int temp: adj.get(node)){\r\n            if(!vis.contains(temp)){\r\n                vis.add(temp);\r\n                bfs(adj,vis,temp);\r\n            }\r\n        }\r\n    }\r\n}"
  },
  {
    "id": "word-ladder",
    "title": "Word Ladder",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "DFS/BFS",
    "statement": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\r\n\r\nEvery adjacent pair of words differs by a single letter.\r\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\r\nsk == endWord\r\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\r\nOutput: 5\r\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\r\nExample 2:\r\n\r\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\r\nOutput: 0\r\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.",
    "solution": "class wordstate {\r\n    String word;\r\n    int state;\r\n    public wordstate(String word, int state){\r\n        this.word = word;\r\n        this.state = state;\r\n    }\r\n}\r\nclass Solution {\r\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\r\n        \r\n        // Queue for BFS \r\n        Queue<wordstate> queue = new LinkedList<>();\r\n        int shortestPath =Integer.MAX_VALUE;\r\n        // to track if already used state\r\n        HashSet<String> visited = new HashSet<>();\r\n        queue.add(new wordstate(beginWord,1));\r\n        visited.add(beginWord);\r\n        while(!queue.isEmpty()){\r\n            wordstate currState = queue.poll();\r\n\r\n            if(currState.word.equals(endWord)){\r\n                shortestPath = Math.min(currState.state,shortestPath);\r\n            }\r\n\r\n            for(String w: wordList){\r\n                boolean state = ifNextState(currState.word,w);\r\n                if( state && !visited.contains(w)){\r\n                    queue.add(new wordstate(w,currState.state + 1));\r\n                    visited.add(w);\r\n                }\r\n            }\r\n        }\r\n        return shortestPath == Integer.MAX_VALUE ? 0 : shortestPath;\r\n    }\r\n\r\n    public boolean ifNextState(String t, String c){\r\n        int diff = 0;\r\n        for(int i=0;i<t.length();i++){\r\n            if(t.charAt(i) != c.charAt(i)){\r\n                if(diff < 1){\r\n                    diff++;\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}"
  },
  {
    "id": "cheapest-flight-within-k-stops",
    "title": "Cheapest Flights Within K Stops",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "DFS/BFS",
    "statement": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\r\n\r\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.\r\n\r\n ",
    "solution": "class Solution {\r\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\r\n        List<List<int[]>> adj = new ArrayList<>();\r\n        for(int i=0;i<n;i++){\r\n            adj.add(new ArrayList<>());\r\n        }\r\n        for(int[] temp: flights){\r\n            // created adj list for flights\r\n            adj.get(temp[0]).add(new int[]{temp[1],temp[2]});\r\n        }\r\n\r\n        Queue<int[]> q = new LinkedList<>();\r\n        // stop,hops,price;\r\n        q.add(new int[]{src,-1,0});\r\n        int min = Integer.MAX_VALUE;        \r\n        int[] visited = new int[n];\r\n        Arrays.fill(visited, Integer.MAX_VALUE);\r\n        visited[src] = 0;\r\n\r\n        while(!q.isEmpty()){\r\n            int[] curr = q.remove();\r\n            \r\n            if(curr[0] == dst && curr[1] <= k){\r\n                min= Math.min(min,curr[2]);\r\n            }\r\n\r\n            for(int i=0;i<adj.get(curr[0]).size();i++){\r\n                int[] next = adj.get(curr[0]).get(i);\r\n                int price = next[1] + curr[2];\r\n                if(visited[next[0]] > price){\r\n                    q.add(new int[]{next[0],curr[1]+1,price});\r\n                    visited[next[0]] = price;\r\n                }\r\n            }\r\n        }\r\n\r\n        return min == Integer.MAX_VALUE ? -1 : min;\r\n\r\n    }\r\n}"
  },
  {
    "id": "longest-increasing-path-matrix",
    "title": "Longest Increasing Path in a Matrix",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "DFS/BFS",
    "statement": "Given an m x n integers matrix, return the length of the longest increasing path in matrix.\r\n\r\nFrom each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]\r\nOutput: 4\r\nExplanation: The longest increasing path is [1, 2, 6, 9].\r\nExample 2:\r\n\r\n\r\nInput: matrix = [[3,4,5],[3,2,6],[2,2,1]]\r\nOutput: 4\r\nExplanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\r\nExample 3:\r\n\r\nInput: matrix = [[1]]\r\nOutput: 1\r\n ",
    "solution": "class Solution {\r\n    int[][] memo = new int[201][201];\r\n    public int longestIncreasingPath(int[][] matrix) {\r\n        int n = matrix.length, m = matrix[0].length;\r\n        int ans =0;\r\n\r\n        for(int i=0;i<n;i++)\r\n            for(int j=0;j<m;j++)\r\n                memo[i][j] = -1;\r\n\r\n        for(int i=0;i<n;i++){\r\n            for(int j=0;j<m;j++){\r\n                ans = Math.max(ans,dfs(matrix,i,j,n,m));\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n\r\n    public int dfs(int[][] mat, int i, int j, int n, int m){\r\n\r\n        if(memo[i][j] != -1)\r\n            return memo[i][j];\r\n        \r\n        int[] row = {-1,0,1,0};\r\n        int[] col = {0,-1,0,1};\r\n        int maxlen = 1;\r\n        for(int k=0;k<4;k++){\r\n            int r = i + row[k];\r\n            int c = j + col[k]; \r\n            if(r>=0 && r<n && c >=0 && c < m && mat[i][j] < mat[r][c])\r\n                maxlen = Math.max(maxlen, 1 + dfs(mat,r,c,n,m));\r\n        }\r\n        memo[i][j] = maxlen;\r\n        return maxlen;\r\n\r\n    }\r\n}"
  },
  {
    "id": "bus-routes",
    "title": "Bus Routes",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "DFS/BFS",
    "statement": "You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.\r\n\r\nFor example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.\r\nYou will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.\r\n\r\nReturn the least number of buses you must take to travel from source to target. Return -1 if it is not possible.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: routes = [[1,2,7],[3,6,7]], source = 1, target = 6\r\nOutput: 2\r\nExplanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\r\nExample 2:\r\n\r\nInput: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\r\nOutput: -1",
    "solution": "class Solution {\r\n    public int numBusesToDestination(int[][] routes, int source, int target) {\r\n        if(source == target)\r\n            return 0;\r\n        \r\n        List<HashSet<Integer>> map = new ArrayList<>();\r\n        Queue<int[]> q = new LinkedList<>();\r\n        boolean[] visited = new boolean[routes.length];\r\n        for(int i=0;i<routes.length;i++){\r\n            HashSet<Integer> hs = new HashSet<>();\r\n            for(int j=0;j<routes[i].length;j++){\r\n                hs.add(routes[i][j]);\r\n            }\r\n            if(hs.contains(source)){\r\n                // bus number and number of buses;\r\n                q.add(new int[]{i,1});\r\n                visited[i] = true;\r\n            }\r\n            map.add(hs);\r\n        }\r\n\r\n        if(q.isEmpty())\r\n            return -1;\r\n\r\n        int min = Integer.MAX_VALUE;\r\n\r\n        while(!q.isEmpty()){\r\n            int[] curr = q.poll();\r\n\r\n            if(map.get(curr[0]).contains(target)){\r\n                min = Math.min(min,curr[1]);\r\n            }\r\n\r\n            for(int i: map.get(curr[0])){\r\n                for(int j=0;j<map.size();j++){\r\n                    if(map.get(j).contains(i) && !visited[j]){\r\n                        visited[j] = true;\r\n                        q.add(new int[]{j,curr[1] +  1});\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        return min == Integer.MAX_VALUE ? -1 : min;\r\n    }\r\n}"
  },
  {
    "id": "Minimum-height-trees",
    "title": "Minimum Height Trees",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "Twisted Topo Sort",
    "statement": "A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.\r\n\r\nGiven a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).\r\n\r\nReturn a list of all MHTs' root labels. You can return the answer in any order.\r\n\r\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.",
    "solution": "class pair {\r\n    int n;\r\n    int d;\r\n    public pair(int n, int d){\r\n        this.n = n;\r\n        this.d = d;\r\n    }\r\n}\r\n\r\nclass Solution {\r\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\r\n        if (n == 1) {\r\n            return Collections.singletonList(0); // Only one node, return the root\r\n        }\r\n        List<List<Integer>> adj = new ArrayList<>();\r\n        int[] indegree = new int[n];\r\n        for(int i=0;i<n;i++){\r\n            adj.add(new ArrayList<>());            \r\n        }\r\n\r\n        for(int i=0;i<edges.length;i++){\r\n            int[] temp = edges[i];\r\n            adj.get(temp[0]).add(temp[1]);\r\n            adj.get(temp[1]).add(temp[0]);\r\n            indegree[temp[0]]++;\r\n            indegree[temp[1]]++;\r\n        }\r\n        Queue<Integer> queue = new LinkedList<>();\r\n\r\n        for(int i=0;i<n;i++){\r\n            if(indegree[i] == 1)\r\n                queue.add(i);\r\n        }\r\n        int remaining_nodes = n;\r\n        while(remaining_nodes > 2){\r\n            int s = queue.size();\r\n            remaining_nodes = remaining_nodes - s;\r\n\r\n            for(int i=0;i<s;i++){\r\n                int curr = queue.remove();\r\n                for(int t: adj.get(curr)){\r\n                    indegree[t]--;\r\n                    if(indegree[t] == 1){\r\n                        queue.add(t);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return new ArrayList<>(queue);\r\n    }\r\n}"
  },
  {
    "id": "swim-in-risising-water",
    "title": "Swim in Rising Water",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "Dijsktra Algo",
    "statement": "You are given a square 2-D matrix of distinct integers grid where each integer grid[i][j] represents the elevation at position (i, j).\r\n\r\nRain starts to fall at time = 0, which causes the water level to rise. At time t, the water level across the entire grid is t.\r\n\r\nYou may swim either horizontally or vertically in the grid between two adjacent squares if the original elevation of both squares is less than or equal to the water level at time t.\r\n\r\nStarting from the top left square (0, 0), return the minimum amount of time it will take until it is possible to reach the bottom right square (n - 1, n - 1).\r\n\r\nExample 1:\r\n\r\n\r\n\r\nInput: grid = [[0,1],[2,3]]\r\n\r\nOutput: 3\r\nExplanation: For a path to exist to the bottom right square grid[1][1] the water elevation must be at least 3. At time t = 3, the water level is 3.\r\n\r\nExample 2:\r\n\r\n\r\n\r\nInput: grid = [\r\n  [0,1,2,10],\r\n  [9,14,4,13],\r\n  [12,3,8,15],\r\n  [11,5,7,6]\r\n]\r\n\r\nOutput: 8",
    "solution": "class Solution {\r\n    public int swimInWater(int[][] grid) {\r\n        int n = grid.length;\r\n        boolean[][] visited = new boolean[n][n];\r\n        Queue<int[]> pq = new PriorityQueue<>((a,b) -> a[2] - b[2]);\r\n        pq.add(new int[]{0,0,grid[0][0]});\r\n        visited[0][0] = true;\r\n\r\n        int[] r = {-1,0,1,0};\r\n        int[] c = {0,1,0,-1};\r\n        int max = Integer.MIN_VALUE;\r\n        while(!pq.isEmpty()){\r\n            int[] curr = pq.poll();\r\n            max = Math.max(max,curr[2]);\r\n\r\n            if(curr[0] == n-1 && curr[1] == n-1)\r\n                return max;\r\n            \r\n            for(int i=0;i<4;i++){\r\n                int nr = r[i] + curr[0];\r\n                int nc = c[i] + curr[1];\r\n\r\n                if(nr >=0 && nc >=0 && nr < n && nc < n && !visited[nr][nc]){\r\n                    visited[nr][nc] = true;\r\n                    pq.add(new int[]{nr,nc,grid[nr][nc]});\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        // dummy \r\n        return 0;\r\n\r\n    }\r\n}"
  },
  {
    "id": "graph-valid-tree",
    "title": "Graph Valid Tree",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "Tree + Graph",
    "statement": "Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\r\n\r\nExample 1:\r\n\r\nInput:\r\nn = 5\r\nedges = [[0, 1], [0, 2], [0, 3], [1, 4]]\r\n\r\nOutput:\r\ntrue\r\nExample 2:\r\n\r\nInput:\r\nn = 5\r\nedges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]\r\n\r\nOutput:\r\nfalse\r\nNote:\r\n\r\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.",
    "solution": "class Node {\r\n    int node;\r\n    int parent;\r\n    public Node(int node, int parent){\r\n        this.node = node;\r\n        this.parent = parent;\r\n    }\r\n}\r\nclass Solution {\r\n    public boolean validTree(int n, int[][] edges) {\r\n        List<List<Integer>> adj = new ArrayList<>();\r\n\r\n        for(int i=0;i<n;i++){\r\n            adj.add(new ArrayList<>());\r\n        }\r\n        for(int[] i: edges){\r\n            adj.get(i[0]).add(i[1]);\r\n            adj.get(i[1]).add(i[0]);\r\n        }\r\n\r\n        Queue<Node> q = new LinkedList<>();\r\n        int[] visited = new int[n];\r\n\r\n        q.add(new Node(0,-1));\r\n        visited[0] = 1;\r\n        while(!q.isEmpty()){\r\n            Node curr = q.poll();\r\n\r\n            for(int i : adj.get(curr.node)){\r\n                if(visited[i] != 1){\r\n                    visited[i] = 1;\r\n                    q.add(new Node(i,curr.node));\r\n                }\r\n                else if(visited[i] == 1 && i != curr.parent){\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        for(int i=0;i<n;i++){\r\n            if(visited[i] != 1)\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n}"
  },
  {
    "id": "network-time-delay",
    "title": "Network Delay Time",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "Dijsktra Algo",
    "statement": "You are given a network of n directed nodes, labeled from 1 to n. You are also given times, a list of directed edges where times[i] = (ui, vi, ti).\r\n\r\nui is the source node (an integer from 1 to n)\r\nvi is the target node (an integer from 1 to n)\r\nti is the time it takes for a signal to travel from the source to the target node (an integer greater than or equal to 0).\r\nYou are also given an integer k, representing the node that we will send a signal from.\r\n\r\nReturn the minimum time it takes for all of the n nodes to receive the signal. If it is impossible for all the nodes to receive the signal, return -1 instead.\r\n\r\nExample 1:\r\n\r\n\r\n\r\nInput: times = [[1,2,1],[2,3,1],[1,4,4],[3,4,1]], n = 4, k = 1\r\n\r\nOutput: 3\r\nExample 2:\r\n\r\nInput: times = [[1,2,1],[2,3,1]], n = 3, k = 2\r\n\r\nOutput: -1\r\nConstraints:\r\n\r\n1 <= k <= n <= 100\r\n1 <= times.length <= 1000",
    "solution": "class Node {\r\n    int n;\r\n    int t;\r\n    public Node(int n, int t){\r\n        this.n = n;\r\n        this.t = t;\r\n    }\r\n}\r\nclass Solution {\r\n    public int networkDelayTime(int[][] times, int n, int k) {\r\n        List<List<Node>> adj = new ArrayList<>();\r\n\r\n        for(int i=0;i<n;i++){\r\n            adj.add(new ArrayList<>());\r\n        }   \r\n\r\n        for(int[] i : times){\r\n            adj.get(i[0] - 1).add(new Node(i[1],i[2]));\r\n        }\r\n\r\n        Queue<int[]> q = new PriorityQueue<>((a,b) -> a[1] - b[1]);\r\n        int[] time = new int[n];\r\n        Arrays.fill(time,Integer.MAX_VALUE);\r\n        time[k -1] = 0;\r\n        q.add(new int[]{k,0});\r\n\r\n        while(!q.isEmpty()){\r\n            int[] curr = q.poll();\r\n            for(Node i: adj.get(curr[0] - 1)){\r\n                if(time[i.n - 1] > curr[1] + i.t ){\r\n                    time[i.n - 1] = curr[1] + i.t;\r\n                    q.add(new int[]{i.n,curr[1] + i.t});\r\n                }\r\n            }\r\n        }\r\n        int ans = 0;\r\n        for(int t : time){\r\n            if(t == Integer.MAX_VALUE) return -1;\r\n            ans = Math.max(ans, t);\r\n        }\r\n        return ans;\r\n    }\r\n}"
  },
  {
    "id": "minimum-cost-to-connect-all-points",
    "title": "Min Cost to Connect All Points",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "Minimum spanning Tree",
    "statement": "You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\r\n\r\nThe cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\r\n\r\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\r\nOutput: 20\r\nExplanation: \r\n\r\nWe can connect the points as shown above to get the minimum cost of 20.\r\nNotice that there is a unique path between every pair of points.\r\nExample 2:\r\n\r\nInput: points = [[3,12],[-2,5],[-4,1]]\r\nOutput: 18",
    "solution": "class pair {\r\n    int n;\r\n    int wt;\r\n    public pair(int n, int wt){\r\n        this.n = n;\r\n        this.wt = wt;\r\n    }\r\n}\r\nclass Solution {\r\n    public int minCostConnectPoints(int[][] points) {\r\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b) -> a.wt - b.wt);\r\n        boolean[] visited = new boolean[points.length];\r\n        int sum =0;\r\n        pq.add(new pair(0,0));\r\n        while(!pq.isEmpty()){\r\n            pair temp = pq.poll();\r\n            if (visited[temp.n]) continue;\r\n            sum = sum + temp.wt;\r\n            visited[temp.n] = true;\r\n            for(int i=0;i<points.length;i++){\r\n                if(!visited[i]){\r\n                    int min = getDistance(points[temp.n][0],points[temp.n][1],points[i][0], points[i][1]);\r\n                    pq.add(new pair(i,min));\r\n                }\r\n            }\r\n            System.out.println();\r\n        }\r\n\r\n        return sum;\r\n        \r\n    }\r\n\r\n    public int getDistance(int x1, int y1, int x2, int y2){\r\n        return Math.abs(x1-x2) + Math.abs(y1-y2);\r\n    }\r\n}"
  },
  {
    "id": "redundant-connection",
    "title": "Redundant Connection",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "UnionFind/DisjointSet",
    "statement": "You are given a connected undirected graph with n nodes labeled from 1 to n. Initially, it contained no cycles and consisted of n-1 edges.\r\n\r\nWe have now added one additional edge to the graph. The edge has two different vertices chosen from 1 to n, and was not an edge that previously existed in the graph.\r\n\r\nThe graph is represented as an array edges of length n where edges[i] = [ai, bi] represents an edge between nodes ai and bi in the graph.\r\n\r\nReturn an edge that can be removed so that the graph is still a connected non-cyclical graph. If there are multiple answers, return the edge that appears last in the input edges.\r\n\r\nExample 1:\r\n\r\n\r\n\r\nInput: edges = [[1,2],[1,3],[3,4],[2,4]]\r\n\r\nOutput: [2,4]\r\nExample 2:\r\n\r\n\r\n\r\nInput: edges = [[1,2],[1,3],[1,4],[3,4],[4,5]]\r\n\r\nOutput: [3,4]",
    "solution": "class UnionFind {\r\n    int[] parent;\r\n    int[] size;\r\n\r\n    public UnionFind(int n){\r\n        parent = new int[n+1];\r\n        size = new int[n+1];\r\n        for(int i=1;i<=n;i++){\r\n            parent[i] = i;\r\n            size[i] = 1;\r\n        }\r\n    }\r\n\r\n    public int findParent(int n){\r\n        if(parent[n] == n)\r\n            return n;\r\n        \r\n        parent[n] = findParent(parent[n]);\r\n        return parent[n];\r\n    }\r\n\r\n    public boolean union(int a, int b){\r\n        int parentA = findParent(a);\r\n        int parentB = findParent(b);\r\n\r\n        if(parentA == parentB)\r\n            return false;\r\n        else {\r\n            if(size[parentA] > size[parentB]){\r\n                parent[parentA] = parentB;\r\n                size[parentB] = size[parentA] + size[parentB];\r\n            }\r\n            else {\r\n                parent[parentB] = parentA;\r\n                size[parentA] = size[parentA] + size[parentB];\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n}\r\nclass Solution {\r\n    public int[] findRedundantConnection(int[][] edges) {\r\n        HashSet<Integer> hs = new HashSet<>();\r\n        for(int[] i: edges){\r\n            hs.add(i[0]);\r\n            hs.add(i[1]);\r\n        }\r\n\r\n        UnionFind uf = new UnionFind(hs.size());\r\n\r\n        for(int[] i : edges){\r\n            if(!uf.union(i[0],i[1])){\r\n                return new int[]{i[0],i[1]};\r\n            }\r\n        }\r\n\r\n        return new int[]{};\r\n    }\r\n}"
  },
  {
    "id": "alien-dictionary",
    "title": "Alien Dictionary",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "Topo Sort",
    "statement": "There is a foreign language which uses the latin alphabet, but the order among letters is not \"a\", \"b\", \"c\" ... \"z\" as in English.\r\n\r\nYou receive a list of non-empty strings words from the dictionary, where the words are sorted lexicographically based on the rules of this new language.\r\n\r\nDerive the order of letters in this language. If the order is invalid, return an empty string. If there are multiple valid order of letters, return any of them.\r\n\r\nA string a is lexicographically smaller than a string b if either of the following is true:\r\n\r\nThe first letter where they differ is smaller in a than in b.\r\na is a prefix of b and a.length < b.length.\r\nExample 1:\r\n\r\nInput: [\"z\",\"o\"]\r\n\r\nOutput: \"zo\"\r\nExplanation:\r\nFrom \"z\" and \"o\", we know 'z' < 'o', so return \"zo\".\r\n\r\nExample 2:\r\n\r\nInput: [\"hrn\",\"hrf\",\"er\",\"enn\",\"rfnn\"]\r\n\r\nOutput: \"hernf\"\r\nExplanation:\r\n\r\nfrom \"hrn\" and \"hrf\", we know 'n' < 'f'\r\nfrom \"hrf\" and \"er\", we know 'h' < 'e'\r\nfrom \"er\" and \"enn\", we know get 'r' < 'n'\r\nfrom \"enn\" and \"rfnn\" we know 'e'<'r'\r\nso one possibile solution is \"hernf\"\r\nConstraints:\r\n\r\nThe input words will contain characters only from lowercase 'a' to 'z'.\r\n1 <= words.length <= 100\r\n1 <= words[i].length <= 100",
    "solution": "class Solution {\r\n    public String foreignDictionary(String[] words) {\r\n      // adj list\r\n      List<List<Integer>> adj = new ArrayList<>();\r\n      // hashset \r\n      HashSet<Character> hs = new HashSet<>();\r\n\r\n      for(int i=0;i<26;i++){\r\n        adj.add(new ArrayList<>());\r\n      }\r\n\r\n      for(String s : words){\r\n        for(char c: s.toCharArray()){\r\n            hs.add(c);\r\n        }\r\n      }\r\n\r\n      for(int i=0;i<words.length-1;i++){\r\n        String s1 = words[i];\r\n        String s2 = words[i+1];\r\n\r\n        int n = Math.min(s1.length(),s2.length());\r\n        int flag = 0;\r\n        for(int j=0;j<n;j++){\r\n            if(s1.charAt(j) != s2.charAt(j)){\r\n                flag = 1;\r\n                adj.get(s1.charAt(j) - 'a').add(s2.charAt(j) - 'a');\r\n                break;\r\n            }            \r\n        }\r\n\r\n        if(flag ==0 && s1.length() > s2.length()){\r\n            return \"\";\r\n        }\r\n      }\r\n\r\n      int[] out = topoSort(adj,hs);\r\n      String output = \"\";\r\n      for(int i: out){\r\n        output = output + (char)(i + (int)'a');\r\n      }\r\n      return output;\r\n\r\n    }\r\n\r\n    public int[] topoSort(List<List<Integer>> adj, HashSet<Character> hs){\r\n        int n = hs.size();\r\n        int[] ans = new int[n];\r\n        int[] indegree = new int[26];\r\n        Queue<Integer> q = new LinkedList<>();\r\n\r\n        for(List<Integer> a: adj){\r\n            for(int s: a){\r\n                indegree[s]++;\r\n            }\r\n        }\r\n        \r\n        for(int i=0;i<adj.size();i++){\r\n            if(indegree[i] == 0 && hs.contains((char)(i+'a'))){\r\n                q.add(i);\r\n            }\r\n        }\r\n\r\n        int count =0;\r\n\r\n        while(!q.isEmpty()){\r\n            int curr = q.poll();\r\n            ans[count++] = curr;\r\n\r\n            for(int i : adj.get(curr)){\r\n                indegree[i]--;\r\n                if(indegree[i] == 0)\r\n                    q.add(i);\r\n            }\r\n        }\r\n\r\n        return count == n ? ans : new int[0];\r\n\r\n    }\r\n}"
  },
  {
    "id": "reconstruct-iternary",
    "title": "Reconstruct Itinerary",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "Eulerian Circuit",
    "statement": "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\r\n\r\nAll of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\r\n\r\nFor example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\r\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\r\nOutput: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\r\nExample 2:\r\n\r\n\r\nInput: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\r\nOutput: [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\r\nExplanation: Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\r\n ",
    "solution": "class Solution {\r\n\r\n    Map<String, PriorityQueue<String>> flights;\r\n    LinkedList<String> path;\r\n\r\n    public List<String> findItinerary(List<List<String>> tickets) {\r\n        flights = new HashMap<>();\r\n        path = new LinkedList<>();\r\n        for (List<String> ticket : tickets) {\r\n            flights.putIfAbsent(ticket.get(0), new PriorityQueue<>());\r\n            flights.get(ticket.get(0)).add(ticket.get(1));\r\n        }\r\n        dfs(\"JFK\");\r\n        return path;\r\n    }\r\n\r\n    public void dfs(String departure) {\r\n        PriorityQueue<String> arrivals = flights.get(departure);\r\n        while (arrivals != null && !arrivals.isEmpty())\r\n            dfs(arrivals.poll());\r\n        path.addFirst(departure);\r\n    }\r\n}"
  },
  {
    "id": "eulerian-path-and-circuit",
    "title": "Eulerian path and circuit for undirected graph",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "Eulerian Circuit",
    "statement": "Given an undirected connected graph with v nodes, and e edges, with adjacency list adj. We need to write a function that returns 2 if the graph contains an eulerian circuit or cycle, else if the graph contains an eulerian path, returns 1, otherwise, returns 0.\r\n\r\nA graph is said to be Eulerian if it contains an Eulerian Cycle, a cycle that visits every edge exactly once and starts and ends at the same vertex.\r\nIf a graph contains an Eulerian Path, a path that visits every edge exactly once but starts and ends at different vertices, it is called Semi-Eulerian.\r\n\r\nThe idea is to use some key properties of undirected graphs that help determine whether they are Eulerian (i.e., contain an Eulerian Path or Cycle) or not.\r\n\r\nEulerian Cycle\r\n\r\nA graph has an Eulerian Cycle if and only if the below two conditions are true\r\n\r\nAll vertices with non-zero degree are part of a single connected component. (We ignore isolated vertices— those with zero degree — as they do not affect the cycle.)\r\nEvery vertex in the graph has an even degree.\r\nEulerian Path\r\n\r\nA graph has an Eulerian Path if and only if the below two conditions are true\r\n\r\nAll vertices with non-zero degree must belong to the same connected component. (Same as Eulerian Cycle)\r\nExactly Zero or Two Vertices with Odd Degree:\r\nIf zero vertices have odd degree → Eulerian Cycle exists (which is also a path).\r\nIf two vertices have odd degree → Eulerian Path exists (but not a cycle).\r\nIf one vertex has odd degree → Not possible in an undirected graph. (Because the sum of all degrees in an undirected graph is always even.)\r\nNote: A graph with no edges is trivially Eulerian. There are no edges to traverse, so by definition, it satisfies both Eulerian Path and Cycle conditions.\r\n\r\nHow Does This Work? \r\n\r\nIn an Eulerian Path, whenever we enter a vertex (except start and end), we must also leave it. So all intermediate vertices must have even degree.\r\nIn an Eulerian Cycle, since we start and end at the same vertex, every vertex must have even degree. This ensures that every entry into a vertex can be paired with an exit.",
    "solution": "// Java program to check whether a graph is\r\n// Eulerian Path, Eulerian Circuit, or neither\r\nimport java.util.*;\r\n\r\nclass GfG {\r\n\r\n    // DFS to check connectivity, excluding zero-degree vertices\r\n    static void dfs(int node, List<Integer>[] adj, boolean[] visited) {\r\n        visited[node] = true;\r\n\r\n        for (int neighbor : adj[node]) {\r\n            if (!visited[neighbor]) {\r\n                dfs(neighbor, adj, visited);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function to check Eulerian Path or Circuit\r\n    static int isEulerCircuit(int v, List<Integer>[] adj) {\r\n        boolean[] visited = new boolean[v];\r\n\r\n        // Find first vertex with non-zero degree\r\n        int start = -1;\r\n        for (int i = 0; i < v; i++) {\r\n            if (adj[i].size() > 0) {\r\n                start = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // No edges: graph is trivially Eulerian\r\n        if (start == -1) {\r\n            return 2;\r\n        }\r\n\r\n        // DFS from the first non-zero degree vertex\r\n        dfs(start, adj, visited);\r\n\r\n        // Check if all non-zero degree vertices are connected\r\n        for (int i = 0; i < v; i++) {\r\n            if (adj[i].size() > 0 && !visited[i]) {\r\n                return 0; // Not connected\r\n            }\r\n        }\r\n\r\n        // Count vertices with odd degree\r\n        int odd = 0;\r\n        for (int i = 0; i < v; i++) {\r\n            if (adj[i].size() % 2 != 0) {\r\n                odd++;\r\n            }\r\n        }\r\n\r\n        // Apply Eulerian rules\r\n        if (odd == 0) {\r\n            return 2; \r\n        } else if (odd == 2) {\r\n            return 1; \r\n        } else {\r\n            return 0; \r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        int v = 5;\r\n        List<Integer>[] adj = new ArrayList[v];\r\n        for (int i = 0; i < v; i++) {\r\n            adj[i] = new ArrayList<>();\r\n        }\r\n\r\n        adj[0].addAll(Arrays.asList(1, 2, 3));\r\n        adj[1].addAll(Arrays.asList(0, 2));\r\n        adj[2].addAll(Arrays.asList(1, 0));\r\n        adj[3].addAll(Arrays.asList(0, 4));\r\n        adj[4].addAll(Arrays.asList(3));\r\n\r\n        System.out.println(isEulerCircuit(v, adj));\r\n    }\r\n}"
  },
  {
    "id": "climbing-stair",
    "title": "Climbing Stairs",
    "topic": "DP",
    "difficulty": "Easy",
    "tags": "1D DP",
    "statement": "You are given an integer n representing the number of steps to reach the top of a staircase. You can climb with either 1 or 2 steps at a time.\r\n\r\nReturn the number of distinct ways to climb to the top of the staircase.\r\n\r\nExample 1:\r\n\r\nInput: n = 2\r\n\r\nOutput: 2\r\nExplanation:\r\n\r\n1 + 1 = 2\r\n2 = 2\r\nExample 2:\r\n\r\nInput: n = 3\r\n\r\nOutput: 3",
    "solution": "class Solution {\r\n    public int climbStairs(int n) {\r\n        if(n == 1)\r\n            return 1;\r\n        \r\n        int[] dp = new int[n+1];\r\n        dp[0] = 1;\r\n        dp[1] = 1;\r\n        for(int i=2;i<=n;i++){\r\n            dp[i] = dp[i-1] + dp[i-2]; \r\n        }\r\n\r\n        return dp[n];\r\n    }\r\n\r\n    public int recur(int n){\r\n        if(n == 0)\r\n         return 1;\r\n        \r\n        if(n < 0)\r\n            return 0;\r\n\r\n        return recur(n-1) + recur(n-2);\r\n    }\r\n}\r\n\r\n\r\n/*\r\nn \r\n\r\n\r\n\r\n*/"
  },
  {
    "id": "minimum-cost-climbing-stairs",
    "title": "Minimum Cost climbing stairs",
    "topic": "DP",
    "difficulty": "Easy",
    "tags": "1D DP",
    "statement": "You are given an array of integers cost where cost[i] is the cost of taking a step from the ith floor of a staircase. After paying the cost, you can step to either the (i + 1)th floor or the (i + 2)th floor.\r\n\r\nYou may choose to start at the index 0 or the index 1 floor.\r\n\r\nReturn the minimum cost to reach the top of the staircase, i.e. just past the last index in cost.\r\n\r\nExample 1:\r\n\r\nInput: cost = [1,2,3]\r\n\r\nOutput: 2\r\nExplanation: We can start at index = 1 and pay the cost of cost[1] = 2 and take two steps to reach the top. The total cost is 2.\r\n\r\nExample 2:\r\n\r\nInput: cost = [1,2,1,2,1,1,1]\r\n\r\nOutput: 4",
    "solution": "class Solution {\r\n    public int minCostClimbingStairs(int[] cost) {\r\n        int n = cost.length;\r\n        int[] dp = new int[n+1];\r\n        dp[0] = 0;\r\n        dp[1] = 0;\r\n        for(int i=2;i<=n;i++){\r\n            dp[i] = Math.min(dp[i-1] + cost[i-1],dp[i-2] + cost[i-2]);\r\n        }\r\n        //return Math.min(minsteps(cost,0,cost.length),minsteps(cost,1,cost.length));\r\n        return dp[n];\r\n    }\r\n\r\n    public int minsteps(int[] cost, int i, int n){\r\n        if(i == n)\r\n            return 0;\r\n\r\n        if ( i > n)\r\n            return 0;\r\n        \r\n        int left = cost[i] + minsteps(cost, i+1, n);\r\n        int right = cost[i] + minsteps(cost, i+2, n);\r\n\r\n        return Math.min(left,right);\r\n    }\r\n}"
  },
  {
    "id": "house-robber",
    "title": "House Robber",
    "topic": "DP",
    "difficulty": "Easy",
    "tags": "1D DP",
    "statement": "You are given an integer array nums where nums[i] represents the amount of money the ith house has. The houses are arranged in a straight line, i.e. the ith house is the neighbor of the (i-1)th and (i+1)th house.\r\n\r\nYou are planning to rob money from the houses, but you cannot rob two adjacent houses because the security system will automatically alert the police if two adjacent houses were both broken into.\r\n\r\nReturn the maximum amount of money you can rob without alerting the police.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,1,3,3]\r\n\r\nOutput: 4\r\nExplanation: nums[0] + nums[2] = 1 + 3 = 4.\r\n\r\nExample 2:\r\n\r\nInput: nums = [2,9,8,3,6]\r\n\r\nOutput: 16",
    "solution": "class Solution {\r\n    public int rob(int[] nums) {\r\n        int n = nums.length;\r\n        if(n == 1)\r\n            return nums[0];\r\n        int[] dp = new int[n];\r\n        dp[0] = nums[0];\r\n        dp[1] = Math.max(nums[0],nums[1]);\r\n        for(int i=2;i<n;i++){\r\n            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\r\n        }\r\n\r\n        return dp[n-1];\r\n    }\r\n}"
  },
  {
    "id": "house-robber-2",
    "title": "House Robber 2",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "1D DP",
    "statement": "You are given an integer array nums where nums[i] represents the amount of money the ith house has. The houses are arranged in a circle, i.e. the first house and the last house are neighbors.\r\n\r\nYou are planning to rob money from the houses, but you cannot rob two adjacent houses because the security system will automatically alert the police if two adjacent houses were both broken into.\r\n\r\nReturn the maximum amount of money you can rob without alerting the police.\r\n\r\nExample 1:\r\n\r\nInput: nums = [3,4,3]\r\n\r\nOutput: 4\r\nExplanation: You cannot rob nums[0] + nums[2] = 6 because nums[0] and nums[2] are adjacent houses. The maximum you can rob is nums[1] = 4.\r\n\r\nExample 2:\r\n\r\nInput: nums = [2,9,8,3,6]\r\n\r\nOutput: 15\r\nExplanation: You cannot rob nums[0] + nums[2] + nums[4] = 16 because nums[0] and nums[4] are adjacent houses. The maximum you can rob is nums[1] + nums[4] = 15.\r\n\r\nConstraints:\r\n\r\n1 <= nums.length <= 100\r\n0 <= nums[i] <= 100",
    "solution": "class Solution {\r\n    public int rob(int[] nums) {\r\n\r\n        if(nums.length == 1)\r\n            return nums[0];\r\n\r\n        int[] arr1 = new int[nums.length-1];\r\n        int[] arr2 = new int[nums.length-1];\r\n\r\n        for(int i=0;i<nums.length -1;i++){\r\n            arr1[i] = nums[i];\r\n        }\r\n\r\n        for(int i=1;i<nums.length;i++){\r\n            arr2[i-1] = nums[i];\r\n        }\r\n\r\n        int a = robs(arr1);\r\n        int b = robs(arr2);\r\n\r\n        return a > b ? a: b;\r\n\r\n    }\r\n\r\n\r\n    public int robs(int[] nums) {\r\n        int[] dp = new int[nums.length];   \r\n        if(nums.length == 1){\r\n            return nums[0];\r\n        }\r\n        int max = nums[0];\r\n        for(int i=0;i<nums.length;i++)\r\n            dp[i] = nums[i];\r\n        for(int i=1;i<nums.length;i++){\r\n            int j = 0;\r\n            while(j < i){\r\n                if(j+1 == i){\r\n                    dp[i] = Math.max(max,dp[i]);\r\n                }\r\n                else{\r\n                    dp[i] = dp[j] + nums[i];\r\n                }\r\n                if(dp[i] > max){\r\n                    max = dp[i];\r\n                }\r\n                j++;\r\n            }\r\n        }\r\n        return max;      \r\n    }\r\n\r\n}"
  },
  {
    "id": "longest-palindromic-substring",
    "title": "Longest Palindromic Substring",
    "topic": "String",
    "difficulty": "Medium",
    "tags": "Two pointers",
    "statement": "Given a string s, return the longest substring of s that is a palindrome.\r\n\r\nA palindrome is a string that reads the same forward and backward.\r\n\r\nIf there are multiple palindromic substrings that have the same length, return any one of them.\r\n\r\nExample 1:\r\n\r\nInput: s = \"ababd\"\r\n\r\nOutput: \"bab\"\r\nExplanation: Both \"aba\" and \"bab\" are valid answers.\r\n\r\nExample 2:\r\n\r\nInput: s = \"abbc\"\r\n\r\nOutput: \"bb\"",
    "solution": "class Solution {\r\n    public String longestPalindrome(String s) {\r\n        String output = \"\";\r\n        int max = Integer.MIN_VALUE;\r\n        for(int i=0;i<s.length();i++){\r\n            String odd = isPalindrome(s,i,i);\r\n            String even = isPalindrome(s,i,i+1);\r\n            String temp = odd.length() > even.length() ? odd: even;\r\n\r\n            if(output.length() < temp.length()){\r\n                output = temp;\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    public String isPalindrome(String s, int i, int j){\r\n        String p = \"\";\r\n        while(i>=0 && j < s.length()){\r\n            if(s.charAt(i) == s.charAt(j)){\r\n                p = s.substring(i,j+1);\r\n                i--;\r\n                j++;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return p;\r\n    }\r\n}"
  },
  {
    "id": "palindromic-substring",
    "title": "Palindromic Substrings",
    "topic": "String",
    "difficulty": "Medium",
    "tags": "Two pointers",
    "statement": "Given a string s, return the number of palindromic substrings in it.\r\n\r\nA string is a palindrome when it reads the same backward as forward.\r\n\r\nA substring is a contiguous sequence of characters within the string.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"abc\"\r\nOutput: 3\r\nExplanation: Three palindromic strings: \"a\", \"b\", \"c\".\r\nExample 2:\r\n\r\nInput: s = \"aaa\"\r\nOutput: 6\r\nExplanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".",
    "solution": "class Solution {\r\n    int count = 1;\r\n    public int countSubstrings(String s) {\r\n        if(s.length()==0) \r\n            return 0;\r\n        \r\n        for(int i=0;i<s.length()-1;i++){\r\n            findPali(s,i,i);\r\n            findPali(s,i,i+1);\r\n        }\r\n        return count;\r\n    }\r\n    public void findPali(String s, int l, int r){\r\n        while(l>=0 && r<s.length() && s.charAt(l) == s.charAt(r)){\r\n            count++;\r\n            l--;\r\n            r++;\r\n        }\r\n    }\r\n}"
  },
  {
    "id": "decode-ways",
    "title": "Decode Ways",
    "topic": "String",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "A string consisting of uppercase english characters can be encoded to a number using the following mapping:\r\n\r\n'A' -> \"1\"\r\n'B' -> \"2\"\r\n...\r\n'Z' -> \"26\"\r\nTo decode a message, digits must be grouped and then mapped back into letters using the reverse of the mapping above. There may be multiple ways to decode a message. For example, \"1012\" can be mapped into:\r\n\r\n\"JAB\" with the grouping (10 1 2)\r\n\"JL\" with the grouping (10 12)\r\nThe grouping (1 01 2) is invalid because 01 cannot be mapped into a letter since it contains a leading zero.\r\n\r\nGiven a string s containing only digits, return the number of ways to decode it. You can assume that the answer fits in a 32-bit integer.\r\n\r\nExample 1:\r\n\r\nInput: s = \"12\"\r\n\r\nOutput: 2\r\n\r\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\r\nExample 2:\r\n\r\nInput: s = \"01\"\r\n\r\nOutput: 0",
    "solution": "class Solution {\r\n    HashMap<Integer,Character> map = new HashMap<>();\r\n    public int numDecodings(String s) {\r\n        char c = 'A';\r\n        for(int i=1;i<=26;i++){\r\n            map.put(i,c);\r\n            c = (char)((int)c + 1);\r\n        }\r\n\r\n        return dfs(s,0);\r\n    }\r\n\r\n    private int dfs(String s, int i) {\r\n        if (i == s.length()) return 1;\r\n        if (s.charAt(i) == '0') return 0;\r\n\r\n        int res = dfs(s,i + 1);\r\n        if (i < s.length() - 1) {\r\n            if (map.containsKey(Integer.parseInt(s.substring(i,i+2)))) {\r\n                res += dfs(s,i + 2);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n// 1 0 1 2\r\n// 1 1 1 2"
  },
  {
    "id": "partition-equal-subset-sum",
    "title": "Partition Equal Subset Sum",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "01 Knapsack DP",
    "statement": "You are given an array of positive integers nums.\r\n\r\nReturn true if you can partition the array into two subsets, subset1 and subset2 where sum(subset1) == sum(subset2). Otherwise, return false.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,4]\r\n\r\nOutput: true\r\nExplanation: The array can be partitioned as [1, 4] and [2, 3].\r\n\r\nExample 2:\r\n\r\nInput: nums = [1,2,3,4,5]\r\n\r\nOutput: false\r\nConstraints:\r\n\r\n1 <= nums.length <= 100\r\n1 <= nums[i] <= 50",
    "solution": "class Solution {\r\n    public boolean canPartition(int[] nums) {\r\n        int total = 0;\r\n        for(int n : nums){\r\n            total = total + n;\r\n        }\r\n        if(total % 2 != 0)\r\n            return false;\r\n        int target = total / 2;\r\n        int n = nums.length;\r\n        boolean[][] dp = new boolean[n+1][target+1];\r\n\r\n        for(int i=0;i<=n;i++){\r\n            dp[i][0] = true;\r\n        }\r\n\r\n        for(int i=1;i<=n;i++){\r\n            for(int j=1;j<=target;j++){\r\n                boolean notTake = dp[i-1][j];\r\n                boolean take = false;\r\n                if(nums[i-1] <= j)\r\n                    take = dp[i-1][j-nums[i-1]];\r\n                dp[i][j] = notTake || take;\r\n            }\r\n        }\r\n\r\n        return dp[n][target];\r\n\r\n        //return check(0,total/2,nums);\r\n\r\n    }\r\n\r\n    public boolean check(int index, int sum, int[] nums){\r\n        if(sum == 0)\r\n            return true;\r\n        \r\n        if(sum < 0 || index >= nums.length)\r\n            return false;\r\n        \r\n        return check(index+1,sum,nums) || check(index+1,sum-nums[index],nums);\r\n    }\r\n}\r\n\r\n/*\r\n[1,2,3,4]\r\ntotal = 1 + 2 + 3 + 4 = 10;\r\ntarget = total /2 ;\r\nsum == target \r\n    true\r\n*/"
  },
  {
    "id": "coin-change",
    "title": "Coin Change",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "unbounded Knapsack",
    "statement": "You are given an integer array coins representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer amount representing a target amount of money.\r\n\r\nReturn the fewest number of coins that you need to make up the exact target amount. If it is impossible to make up the amount, return -1.\r\n\r\nYou may assume that you have an unlimited number of each coin.\r\n\r\nExample 1:\r\n\r\nInput: coins = [1,5,10], amount = 12\r\n\r\nOutput: 3\r\nExplanation: 12 = 10 + 1 + 1. Note that we do not have to use every kind coin available.\r\n\r\nExample 2:\r\n\r\nInput: coins = [2], amount = 3\r\n\r\nOutput: -1\r\nExplanation: The amount of 3 cannot be made up with coins of 2.\r\n\r\nExample 3:\r\n\r\nInput: coins = [1], amount = 0\r\n\r\nOutput: 0",
    "solution": "class Solution {\r\n    HashMap<Integer,Integer> map = new HashMap<>();\r\n    public int coinChange(int[] coins, int amount) {\r\n        if (amount == 0)\r\n            return 0;\r\n        \r\n        int value = recur(coins,amount);\r\n        return value >= 1e9 ? -1 : value;\r\n    }\r\n\r\n    public int recur(int[] coins, int amount){\r\n        if(amount == 0)\r\n            return 0;\r\n        \r\n        if(map.containsKey(amount))\r\n            return map.get(amount);\r\n\r\n        int count = (int) 1e9;\r\n        for(int i: coins){\r\n            if(amount - i >= 0){\r\n                count = Math.min(count, 1 + recur(coins,amount - i));                \r\n            }\r\n        }\r\n        map.put(amount,count);\r\n        return count;\r\n    }\r\n}"
  },
  {
    "id": "maximum-product-subarray",
    "title": "Maximum Product Subarray",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "DP, Kadane algorithm",
    "statement": "Given an integer array nums, find a subarray that has the largest product within the array and return it.\r\n\r\nA subarray is a contiguous non-empty sequence of elements within an array.\r\n\r\nYou can assume the output will fit into a 32-bit integer.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,-3,4]\r\n\r\nOutput: 4\r\nExample 2:\r\n\r\nInput: nums = [-2,-1]\r\n\r\nOutput: 2",
    "solution": "class Solution {\r\n    public int maxProduct(int[] nums) {\r\n        int n = nums.length;\r\n\r\n        int prefix = 0, suffix = 0;\r\n        int max_product = nums[0];\r\n\r\n        for(int i=0;i<n;i++){\r\n            prefix = nums[i] * (prefix == 0 ? 1 : prefix);\r\n            suffix = nums[n - i - 1] * (suffix == 0 ? 1 : suffix);\r\n\r\n            max_product = Math.max(max_product, Math.max(prefix,suffix));\r\n        }\r\n\r\n        return max_product;\r\n    }\r\n}"
  },
  {
    "id": "word-break",
    "title": "Word Break",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of dictionary words.\r\n\r\nYou are allowed to reuse words in the dictionary an unlimited number of times. You may assume all dictionary words are unique.\r\n\r\nExample 1:\r\n\r\nInput: s = \"neetcode\", wordDict = [\"neet\",\"code\"]\r\n\r\nOutput: true\r\nExplanation: Return true because \"neetcode\" can be split into \"neet\" and \"code\".\r\n\r\nExample 2:\r\n\r\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\",\"ape\"]\r\n\r\nOutput: true\r\nExplanation: Return true because \"applepenapple\" can be split into \"apple\", \"pen\" and \"apple\". Notice that we can reuse words and also not use all the words.\r\n\r\nExample 3:\r\n\r\nInput: s = \"catsincars\", wordDict = [\"cats\",\"cat\",\"sin\",\"in\",\"car\"]\r\n\r\nOutput: false",
    "solution": "class Solution {\r\n    public boolean wordBreak(String s, List<String> wordDict) {\r\n        boolean[] dp = new boolean[s.length() + 1];\r\n        dp[s.length()] = true;\r\n        for(int i=s.length() -1;i>=0;i--){\r\n            String curr = s.substring(i,s.length());\r\n            for(int j=0;j<wordDict.size();j++){\r\n                if(wordDict.get(j).length() <= curr.length() && curr.startsWith(wordDict.get(j))){\r\n                    dp[i] = dp[i+wordDict.get(j).length()];   \r\n                }\r\n                if(dp[i])\r\n                    break;\r\n            }\r\n        }\r\n        return dp[0];\r\n    }\r\n\r\n    public boolean dfs(List<String> word, String s, int index, Boolean[] dp){\r\n        if(index == s.length()){\r\n            return true;\r\n        }\r\n\r\n        if(dp[index] != null){\r\n            return dp[index];\r\n        }\r\n        \r\n        for(int i=0;i<word.size();i++){\r\n            String curr = s.substring(index,s.length());\r\n            if(word.get(i).length() <= curr.length() && curr.startsWith(word.get(i)) && dfs(word,s,index + word.get(i).length(),dp)){\r\n                return true;\r\n            }\r\n        }\r\n\r\n        dp[index] = false;\r\n        return false;\r\n    }\r\n}"
  },
  {
    "id": "longest-increasing-subsequence",
    "title": "Longest Increasing Subsequence",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "Given an integer array nums, return the length of the longest strictly increasing subsequence.\r\n\r\nA subsequence is a sequence that can be derived from the given sequence by deleting some or no elements without changing the relative order of the remaining characters.\r\n\r\nFor example, \"cat\" is a subsequence of \"crabt\".\r\nExample 1:\r\n\r\nInput: nums = [9,1,4,2,3,3,7]\r\n\r\nOutput: 4\r\nExplanation: The longest increasing subsequence is [1,2,3,7], which has a length of 4.\r\n\r\nExample 2:\r\n\r\nInput: nums = [0,3,1,3,2,3]\r\n\r\nOutput: 4",
    "solution": "class Solution {\r\n    public int lengthOfLIS(int[] nums) {\r\n        int[][] dp = new int[nums.length][nums.length + 1];\r\n        for(int[] d : dp)\r\n            Arrays.fill(d,-1);\r\n        return dfs(nums,0,-1,dp);\r\n    }\r\n\r\n    public int dfs(int[] nums, int index, int preIndex, int[][] dp){\r\n        if(index == nums.length)\r\n            return 0;\r\n\r\n        if(dp[index][preIndex + 1] != -1)\r\n            return dp[index][preIndex + 1];\r\n\r\n        int take = 0;\r\n        if(preIndex == -1 || nums[index] > nums[preIndex]){\r\n            take = 1 + dfs(nums,index+1,index, dp);\r\n        }\r\n\r\n        int notTake = dfs(nums,index+1,preIndex,dp);\r\n        \r\n        dp[index][preIndex + 1] = Math.max(take,notTake); \r\n        return dp[index][preIndex + 1];\r\n    }\r\n}\r\n\r\n// [9,1,4,2,3]"
  },
  {
    "id": "maximum-subarray",
    "title": "Maximum Subarray",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\r\nOutput: 6\r\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\r\nExample 2:\r\n\r\nInput: nums = [1]\r\nOutput: 1\r\nExplanation: The subarray [1] has the largest sum 1.\r\nExample 3:\r\n\r\nInput: nums = [5,4,-1,7,8]\r\nOutput: 23\r\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\r\n \r\n\r\nConstraints:\r\n\r\n1 <= nums.length <= 105\r\n-104 <= nums[i] <= 104",
    "solution": "class Solution {\r\n    public int maxSubArray(int[] nums) {\r\n        int max = nums[0], sum = nums[0];\r\n\r\n        for(int i=1;i<nums.length;i++){\r\n            sum = (nums[i] > sum + nums[i]) ? nums[i] : sum + nums[i];\r\n\r\n            max = Math.max(max,sum);\r\n        }\r\n        return max;\r\n    }\r\n}"
  },
  {
    "id": "longest-common-subsequence",
    "title": "Longest Common Subsequence",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "DP subsequence",
    "statement": "Given two strings text1 and text2, return the length of the longest common subsequence between the two strings if one exists, otherwise return 0.\r\n\r\nA subsequence is a sequence that can be derived from the given sequence by deleting some or no elements without changing the relative order of the remaining characters.\r\n\r\nFor example, \"cat\" is a subsequence of \"crabt\".\r\nA common subsequence of two strings is a subsequence that exists in both strings.\r\n\r\nExample 1:\r\n\r\nInput: text1 = \"cat\", text2 = \"crabt\" \r\n\r\nOutput: 3 \r\nExplanation: The longest common subsequence is \"cat\" which has a length of 3.\r\n\r\nExample 2:\r\n\r\nInput: text1 = \"abcd\", text2 = \"abcd\"\r\n\r\nOutput: 4\r\nExample 3:\r\n\r\nInput: text1 = \"abcd\", text2 = \"efgh\"\r\n\r\nOutput: 0",
    "solution": "class Solution {\r\n    public int longestCommonSubsequence(String text1, String text2) {\r\n        int[][] dp = new int[text1.length() + 1][text2.length() + 1];\r\n        for(int i=0;i<text1.length();i++){\r\n            for(int j=0;j<text2.length();j++){\r\n                dp[i][j] = -1;\r\n            }\r\n        }\r\n        return lcs(text1,text2,0,0, dp);\r\n\r\n    }\r\n\r\n    public int lcs(String text1, String text2, int i, int j, int[][] dp){\r\n\r\n        if(i >= text1.length() || j >= text2.length())\r\n            return 0;\r\n        \r\n        if(dp[i][j] != -1)\r\n            return dp[i][j];\r\n        \r\n        System.out.println(text1.charAt(i)+\",\"+text2.charAt(j));\r\n        int take = 0;\r\n        if(text1.charAt(i) == text2.charAt(j))\r\n            take = 1 + lcs(text1,text2,i+1,j+1,dp);\r\n        \r\n        int Nottake1 = lcs(text1,text2,i,j+1,dp);\r\n        int nottake2 = lcs(text1,text2,i+1,j,dp);\r\n\r\n        dp[i][j] = Math.max(take,Math.max(Nottake1,nottake2));\r\n\r\n        return dp[i][j];\r\n\r\n    }\r\n}\r\n\r\n\r\n// def abd"
  },
  {
    "id": "best-time-to-buy-sell-cooldown",
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\r\n\r\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\r\n\r\nAfter you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\r\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: prices = [1,2,3,0,2]\r\nOutput: 3\r\nExplanation: transactions = [buy, sell, cooldown, buy, sell]\r\nExample 2:\r\n\r\nInput: prices = [1]\r\nOutput: 0\r\n ",
    "solution": "class Solution {\r\n    public int maxProfit(int[] prices) {\r\n        int[][] dp = new int[prices.length+1][prices.length+1];\r\n\r\n        for(int i=0;i<prices.length;i++){\r\n            for(int j=0;j<prices.length;j++){\r\n                dp[i][j] =1;\r\n            }\r\n        }\r\n        return profit(prices,0,-1,dp);\r\n    }\r\n\r\n    public int profit(int[] prices, int curr, int prev, int[][] dp){\r\n        if(curr >= prices.length)\r\n            return 0;\r\n        \r\n        if(dp[curr][prev+1] != -1)\r\n            return dp[curr][prev+1];\r\n\r\n        int left = 0;\r\n        int right =0;\r\n\r\n        if(prev != -1){\r\n            left = profit(prices,curr+2,-1,dp) + prices[curr] - prices[prev];\r\n            right = profit(prices,curr+1,prev,dp);\r\n        }\r\n        else {\r\n            left = profit(prices,curr+1,curr,dp);\r\n            right = profit(prices,curr+1,-1,dp);\r\n        }\r\n\r\n        dp[curr][prev+1] = Math.max(left,right);\r\n        return dp[curr][prev+1];\r\n    }\r\n}\r\n\r\n// -------------------------- DP -------------------------------\r\n\r\nclass Solution {\r\n    \r\n    int[] memo;\r\n    public int maxProfit(int[] prices) {\r\n        memo = new int[prices.length];\r\n        for(int i=0;i<prices.length;i++)\r\n            memo[i]=-1;\r\n        return maxPro(prices,0,prices.length);\r\n    }\r\n    \r\n    public int maxPro(int[] prices, int curr, int n){\r\n        if(curr>=n)\r\n            return 0;\r\n        \r\n        if(memo[curr]!=-1)\r\n            return memo[curr];\r\n        \r\n        int max =0;\r\n        \r\n        for(int i = curr+1; i<n;i++){\r\n            if(prices[curr]<prices[i]){\r\n                \r\n                max = Math.max(max, (prices[i] - prices[curr]) + maxPro(prices, i +2, n));\r\n            }\r\n        }\r\n        \r\n        max = Math.max(max, maxPro(prices,curr+1,prices.length));\r\n        memo[curr] = max;\r\n        return memo[curr];\r\n    }\r\n}"
  },
  {
    "id": "interleaving-string",
    "title": "Interleaving String",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\r\n\r\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\r\n\r\ns = s1 + s2 + ... + sn\r\nt = t1 + t2 + ... + tm\r\n|n - m| <= 1\r\nThe interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...\r\nNote: a + b is the concatenation of strings a and b.",
    "solution": "class Solution {\r\n    public boolean isInterleave(String s1, String s2, String s3) {\r\n        if(s3.length() < s1.length() + s2.length())\r\n            return false;\r\n        Boolean[][] dp = new Boolean[s1.length()+1][s2.length()+1];\r\n        \r\n        for(int)\r\n        return dfs(s1,s2,s3,0,0,dp);\r\n    }\r\n\r\n    public boolean dfs(String s1, String s2, String s3, int i, int j, Boolean[][] dp){\r\n        if(i+j == s3.length())\r\n            return true;\r\n        \r\n        if(dp[i][j] != null)\r\n            return dp[i][j];\r\n        \r\n        boolean left = false;\r\n        if( i < s1.length() && s1.charAt(i) == s3.charAt(i+j))\r\n            left = dfs(s1,s2,s3,i+1,j,dp);\r\n        \r\n        boolean right = false;\r\n        if(j < s2.length() && s2.charAt(j) == s3.charAt(i+j))\r\n            right = dfs(s1,s2,s3,i,j+1,dp);\r\n\r\n        dp[i][j] = left || right;\r\n        return dp[i][j];\r\n    }\r\n}"
  },
  {
    "id": "coin-change-2",
    "title": "Coin Change II",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\r\n\r\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\r\n\r\nYou may assume that you have an infinite number of each kind of coin.\r\n\r\nThe answer is guaranteed to fit into a signed 32-bit integer.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: amount = 5, coins = [1,2,5]\r\nOutput: 4\r\nExplanation: there are four ways to make up the amount:\r\n5=5\r\n5=2+2+1\r\n5=2+1+1+1\r\n5=1+1+1+1+1\r\nExample 2:\r\n\r\nInput: amount = 3, coins = [2]\r\nOutput: 0\r\nExplanation: the amount of 3 cannot be made up just with coins of 2.\r\nExample 3:\r\n\r\nInput: amount = 10, coins = [10]\r\nOutput: 1\r\n ",
    "solution": "class Solution {\r\n    public int change(int amount, int[] coins) {\r\n        int[][] dp = new  int[coins.length+1][amount+1]; \r\n        for(int i=0;i<coins.length+1;i++){\r\n            Arrays.fill(dp[i],-1);\r\n        }\r\n        return dfs(coins,amount,0,dp);\r\n        \r\n    }\r\n\r\n    public int dfs(int[] coins, int amount, int i,int[][] dp){\r\n        if(amount == 0)\r\n            return 1;\r\n        if(amount < 0 || i >= coins.length)\r\n            return 0;\r\n        \r\n        if(dp[i][amount] != -1)\r\n            return dp[i][amount];\r\n\r\n        int count = 0;\r\n        for(int j=i;j<coins.length;j++){\r\n            if(amount>=coins[j])\r\n                count = count + dfs(coins,amount - coins[j],j,dp);\r\n        }\r\n        dp[i][amount] = count;\r\n        return dp[i][amount];\r\n    }\r\n}"
  },
  {
    "id": "distinct-subsequences",
    "title": "Distinct Subsequences",
    "topic": "DP",
    "difficulty": "Hard",
    "tags": "DP",
    "statement": "You are given two strings s and t, both consisting of english letters.\r\n\r\nReturn the number of distinct subsequences of s which are equal to t.\r\n\r\nExample 1:\r\n\r\nInput: s = \"caaat\", t = \"cat\"\r\n\r\nOutput: 3\r\nExplanation: There are 3 ways you can generate \"cat\" from s.\r\n\r\n(c)aa(at)\r\n(c)a(a)a(t)\r\n(ca)aa(t)\r\nExample 2:\r\n\r\nInput: s = \"xxyxy\", t = \"xy\"\r\n\r\nOutput: 5\r\nExplanation: There are 5 ways you can generate \"xy\" from s.\r\n\r\n(x)x(y)xy\r\n(x)xyx(y)\r\nx(x)(y)xy\r\nx(x)yx(y)\r\nxxy(x)(y)",
    "solution": "class Solution {\r\n    public int numDistinct(String s, String t) {\r\n        return dfs(s,t,0,0);\r\n    }\r\n\r\n    public int dfs(String s, String t, int i, int j){\r\n        if(j == t.length())\r\n            return 1;\r\n        \r\n        if(i >= s.length())\r\n            return 0;\r\n\r\n        int count =0;\r\n        if(s.charAt(i) == t.charAt(j)){\r\n            count = count + dfs(s,t,i+1,j+1);\r\n        }\r\n\r\n        count = count + dfs(s,t,i+1,j);\r\n\r\n        return count;\r\n\r\n    }\r\n}"
  },
  {
    "id": "edit-distance",
    "title": "Edit Distance",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "You are given two strings word1 and word2, each consisting of lowercase English letters.\r\n\r\nYou are allowed to perform three operations on word1 an unlimited number of times:\r\n\r\nInsert a character at any position\r\nDelete a character at any position\r\nReplace a character at any position\r\nReturn the minimum number of operations to make word1 equal word2.\r\n\r\nExample 1:\r\n\r\nInput: word1 = \"monkeys\", word2 = \"money\"\r\n\r\nOutput: 2\r\nExplanation:\r\nmonkeys -> monkey (remove s)\r\nmonkey -> money (remove k)\r\n\r\nExample 2:\r\n\r\nInput: word1 = \"neatcdee\", word2 = \"neetcode\"\r\n\r\nOutput: 3",
    "solution": "class Solution {\r\n    public int minDistance(String word1, String word2) {\r\n        return dfs(word1,word2,0,0);\r\n    }\r\n\r\n    public int dfs(String word1, String word2, int i, int j){\r\n        if(i== word1.length())\r\n            return word2.length() - j;\r\n        if (j == word2.length())\r\n            return word1.length() - i;\r\n        \r\n        int noMatch =0;\r\n        if(word1.charAt(i) == word2.charAt(j))\r\n        {\r\n            return dfs(word1,word2,i+1,j+1);\r\n        }\r\n        else {\r\n            int op1 = 1 + dfs(word1,word2,i,j+1); // insert\r\n            int op2 = 1 + dfs(word1,word2,i+1,j); // delete\r\n            int op3 = 1 + dfs(word1,word2,i+1,j+1); // replace\r\n\r\n            noMatch = Math.min(Math.min(op1,op2),op3);\r\n        }\r\n\r\n        return noMatch;\r\n    }\r\n}"
  },
  {
    "id": "burst-ballons",
    "title": "Burst Balloons",
    "topic": "DP",
    "difficulty": "Hard",
    "tags": "DP",
    "statement": "You are given an array of integers nums of size n. The ith element represents a balloon with an integer value of nums[i]. You must burst all of the balloons.\r\n\r\nIf you burst the ith balloon, you will receive nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then assume the out of bounds value is 1.\r\n\r\nReturn the maximum number of coins you can receive by bursting all of the balloons.\r\n\r\nExample 1:\r\n\r\nInput: nums = [4,2,3,7]\r\n\r\nOutput: 143\r\n\r\nExplanation:\r\nnums = [4,2,3,7] --> [4,3,7] --> [4,7] --> [7] --> []\r\ncoins =  4*2*3    +   4*3*7   +  1*4*7  + 1*7*1 = 143\r\nConstraints:\r\n\r\nn == nums.length\r\n1 <= n <= 300\r\n0 <= nums[i] <= 100",
    "solution": "class Solution {\r\n    public int maxCoins(int[] nums) {\r\n        int n = nums.length;\r\n\r\n        int[] padded = new int[n+2];\r\n        int[][] dp = new int[n+2][n+2];\r\n\r\n        for(int i=0;i<n+2;i++){\r\n            for(int j=0;j<n+2;j++){\r\n                dp[i][j] =-1;\r\n            }\r\n        }\r\n\r\n        padded[0] = 1;\r\n        padded[n+1] = 1;\r\n\r\n        for(int i=1;i<=n;i++)\r\n            padded[i] = nums[i-1];\r\n        \r\n        return coins(padded,1,n,dp);\r\n    }\r\n\r\n    public int coins(int[] nums, int l, int r, int[][] dp){\r\n        if(l > r)\r\n            return 0;\r\n\r\n        if(dp[l][r] != -1)\r\n            return dp[l][r];\r\n\r\n        int max = 0;\r\n        for(int i = l; i<=r;i++){\r\n            int curr = nums[i];\r\n            int prev = nums[l-1];\r\n            int next = nums[r+1];\r\n\r\n            int count =  prev * curr * next + coins(nums,l,i-1, dp) + coins(nums,i+1,r, dp);\r\n            max = Math.max(count,max);\r\n        }\r\n        dp[l][r] = max;\r\n        return dp[l][r];\r\n\r\n    }\r\n}"
  },
  {
    "id": "regular-expression-matching",
    "title": "Regular Expression Matching",
    "topic": "DP",
    "difficulty": "Hard",
    "tags": "DP",
    "statement": "You are given an input string s consisting of lowercase english letters, and a pattern p consisting of lowercase english letters, as well as '.', and '*' characters.\r\n\r\nReturn true if the pattern matches the entire input string, otherwise return false.\r\n\r\n'.' Matches any single character\r\n'*' Matches zero or more of the preceding element.\r\nExample 1:\r\n\r\nInput: s = \"aa\", p = \".b\"\r\n\r\nOutput: false\r\nExplanation: Regardless of which character we choose for the '.' in the pattern, we cannot match the second character in the input string.\r\n\r\nExample 2:\r\n\r\nInput: s = \"nnn\", p = \"n*\"\r\n\r\nOutput: true\r\nExplanation: '*' means zero or more of the preceding element, 'n'. We choose 'n' to repeat three times.\r\n\r\nExample 3:\r\n\r\nInput: s = \"xyz\", p = \".*z\"\r\n\r\nOutput: true\r\nExplanation: The pattern \".*\" means zero or more of any character, so we choose \"..\" to match \"xy\" and \"z\" to match \"z\".",
    "solution": "class Solution {\r\n    public boolean isMatch(String s, String p) {\r\n        return dfs(s,p,0,0);\r\n    }\r\n\r\n    public boolean dfs(String s, String p, int i, int j){\r\n        if( i >= s.length() && j >= p.length())\r\n            return true;\r\n        \r\n        if( j>= p.length())\r\n            return false;\r\n            \r\n        boolean match = i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.');\r\n\r\n        if(j+1 < p.length() && p.charAt(j+1) == '*'){\r\n            return dfs(s,p,i,j+2) || (match && dfs(s,p,i+1,j));\r\n        }\r\n\r\n        if(match)\r\n            return dfs(s,p,i+1,j+1);\r\n\r\n        return false;\r\n    }\r\n}"
  },
  {
    "id": "maximal-square",
    "title": "Maximal Square",
    "topic": "DP",
    "difficulty": "Hard",
    "tags": "DP",
    "statement": "ou are given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\r\n\r\nExample 1:\r\n\r\nInput: matrix = [\r\n    [\"1\",\"0\",\"1\",\"0\",\"0\"],\r\n    [\"1\",\"0\",\"1\",\"1\",\"1\"],\r\n    [\"1\",\"1\",\"1\",\"1\",\"1\"],\r\n    [\"1\",\"0\",\"0\",\"1\",\"0\"]\r\n]\r\n\r\nOutput: 4\r\nExample 2:\r\n\r\nInput: matrix = [\r\n    [\"0\",\"1\"],\r\n    [\"1\",\"0\"]\r\n]\r\n\r\nOutput: 1\r\nConstraints:\r\n\r\n1 <= matrix.length, matrix[i].length <= 300\r\nmatrix[i][j] is '0' or '1'.",
    "solution": "class Solution {\r\n    public int maximalSquare(char[][] matrix) {\r\n        int n = matrix.length;\r\n        int m = matrix[0].length;\r\n\r\n        int[][] dp = new int[n][m];\r\n        int max = Integer.MIN_VALUE;\r\n        for(int i=0;i<n;i++){\r\n            for(int j=0;j<m;j++){\r\n                if(matrix[i][j] == '1'){\r\n                    if( i==0 || j == 0)\r\n                        dp[i][j] = 1;\r\n                    else {\r\n                        dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1;\r\n                    }\r\n                }\r\n                max = Math.max(max,dp[i][j]);\r\n            }\r\n        }\r\n\r\n        return max * max;\r\n\r\n\r\n    }\r\n}"
  },
  {
    "id": "combination-sum-4",
    "title": "Combination Sum IV",
    "topic": "DP",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\r\n\r\nThe test cases are generated so that the answer can fit in a 32-bit integer.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3], target = 4\r\nOutput: 7\r\nExplanation:\r\nThe possible combination ways are:\r\n(1, 1, 1, 1)\r\n(1, 1, 2)\r\n(1, 2, 1)\r\n(1, 3)\r\n(2, 1, 1)\r\n(2, 2)\r\n(3, 1)\r\nNote that different sequences are counted as different combinations.\r\nExample 2:\r\n\r\nInput: nums = [9], target = 3\r\nOutput: 0\r\n \r\n\r\nConstraints:\r\n\r\n1 <= nums.length <= 200\r\n1 <= nums[i] <= 1000\r\nAll the elements of nums are unique.\r\n1 <= target <= 1000",
    "solution": "class Solution {\r\n    public int combinationSum4(int[] nums, int target) {\r\n        int n = nums.length;\r\n        int[] dp = new int[target+1];\r\n        dp[0] = 1;\r\n        for(int i=1;i<=target;i++){\r\n            for(int j=0;j<n;j++){\r\n                if(i-nums[j] >=0){\r\n                    dp[i] = dp[i] + dp[i-nums[j]];\r\n                }\r\n            }\r\n        }\r\n\r\n        return dp[target];\r\n    }\r\n\r\n}"
  },
  {
    "id": "k-closest-points-to-origin",
    "title": "K Closest Points to Origin",
    "topic": "Heap",
    "difficulty": "Medium",
    "tags": "Heap",
    "statement": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\r\n\r\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).\r\n\r\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: points = [[1,3],[-2,2]], k = 1\r\nOutput: [[-2,2]]\r\nExplanation:\r\nThe distance between (1, 3) and the origin is sqrt(10).\r\nThe distance between (-2, 2) and the origin is sqrt(8).\r\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\r\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\r\nExample 2:\r\n\r\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\r\nOutput: [[3,3],[-2,4]]\r\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.",
    "solution": "class Solution {\r\n    public int[][] kClosest(int[][] points, int k) {\r\n        int n = points.length;\r\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> Double.compare(dist(a),dist(b)));\r\n        for(int[] i: points){\r\n            pq.add(i);\r\n        }\r\n\r\n        int[][] output = new int[k][2];\r\n\r\n        for(int i=0;i<k;i++){\r\n            int[] temp = pq.poll();\r\n            output[i][0] = temp[0];\r\n            output[i][1] = temp[1];\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    public double dist(int[] x){\r\n        return Math.sqrt(Math.pow(x[0],2) + Math.pow(x[1],2));\r\n    }\r\n}"
  },
  {
    "id": "task-scheduler",
    "title": "Task Scheduler",
    "topic": "Heap",
    "difficulty": "Medium",
    "tags": "Heap + Queue",
    "statement": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label.\r\n\r\nReturn the minimum number of CPU intervals required to complete all tasks.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\r\n\r\nOutput: 8\r\n\r\nExplanation: A possible sequence is: A -> B -> idle -> A -> B -> idle -> A -> B.\r\n\r\nAfter completing task A, you must wait two intervals before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th interval, you can do A again as 2 intervals have passed.\r\n\r\nExample 2:\r\n\r\nInput: tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1\r\n\r\nOutput: 6\r\n\r\nExplanation: A possible sequence is: A -> B -> C -> D -> A -> B.\r\n\r\nWith a cooling interval of 1, you can repeat a task after just one other task.\r\n\r\nExample 3:\r\n\r\nInput: tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3\r\n\r\nOutput: 10\r\n\r\nExplanation: A possible sequence is: A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B.\r\n\r\nThere are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks.",
    "solution": "class Solution {\r\n    public int leastInterval(char[] tasks, int n) {\r\n        /* 2 queue approach since 2 moving variables and single queue cant handle it */\r\n\r\n        int[] map = new int[26];\r\n\r\n        // create map of frequency\r\n        for(char c: tasks){\r\n            map[c-'A']++;\r\n        }\r\n        \r\n        // sort in revesre order of frequency\r\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> b[1] - a[1]);\r\n\r\n        for(int i=0;i<26;i++){\r\n            if(map[i] > 0){\r\n                pq.add(new int[]{i,map[i]});\r\n            }\r\n        }\r\n\r\n        Queue<int[]> queue = new LinkedList<>();\r\n        int time =0;\r\n        while(!pq.isEmpty()  || !queue.isEmpty()){\r\n            time++;\r\n\r\n            // poll for ready task \r\n            if(!pq.isEmpty()){\r\n                int[] curr = pq.poll();\r\n                curr[1]--;\r\n                if(curr[1] > 0){\r\n                    // queue with cool down\r\n                    queue.add(new int[]{curr[0],curr[1],time + n});\r\n                }\r\n            }\r\n            // if something is back from cooldown\r\n            if(!queue.isEmpty() && queue.peek()[2] == time){\r\n                int[] temp = queue.poll();\r\n                pq.add(new int[]{temp[0],temp[1]});\r\n            }\r\n        }\r\n\r\n        return time; \r\n\r\n\r\n    }\r\n}"
  },
  {
    "id": "top-k-frequent-words",
    "title": "Top K Frequent Words",
    "topic": "Heap",
    "difficulty": "Medium",
    "tags": "Heap",
    "statement": "Given an array of strings words and an integer k, return the k most frequent strings.\r\n\r\nReturn the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\r\nOutput: [\"i\",\"love\"]\r\nExplanation: \"i\" and \"love\" are the two most frequent words.\r\nNote that \"i\" comes before \"love\" due to a lower alphabetical order.\r\nExample 2:\r\n\r\nInput: words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4\r\nOutput: [\"the\",\"is\",\"sunny\",\"day\"]\r\nExplanation: \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.",
    "solution": "class Solution {\r\n    public List<String> topKFrequent(String[] words, int k) {\r\n        HashMap<String,Integer> map = new HashMap<>();\r\n\r\n        for(String s : words){\r\n            map.put(s,map.getOrDefault(s,0)+1);\r\n        }\r\n\r\n        PriorityQueue<String> pq = new PriorityQueue<>((a,b) -> {\r\n            if(map.get(a) == map.get(b)){\r\n                return a.compareTo(b);\r\n            }\r\n            else {\r\n                return map.get(b) - map.get(a);\r\n            }\r\n        });\r\n        \r\n        for(String s : map.keySet()){\r\n            pq.add(s);\r\n        }\r\n\r\n        List<String> list = new ArrayList<>();\r\n\r\n        for(int i=0;i<k;i++){\r\n            list.add(pq.poll());\r\n        }\r\n\r\n        return list;\r\n\r\n    }\r\n}"
  },
  {
    "id": "find-k-closest-elements",
    "title": "Find K Closest Elements",
    "topic": "Heap",
    "difficulty": "Medium",
    "tags": "Heap",
    "statement": "Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.\r\n\r\nAn integer a is closer to x than an integer b if:\r\n\r\n|a - x| < |b - x|, or\r\n|a - x| == |b - x| and a < b\r\n \r\n\r\nExample 1:\r\n\r\nInput: arr = [1,2,3,4,5], k = 4, x = 3\r\n\r\nOutput: [1,2,3,4]\r\n\r\nExample 2:\r\n\r\nInput: arr = [1,1,2,3,4,5], k = 4, x = -1\r\n\r\nOutput: [1,1,2,3]",
    "solution": "class Solution {\r\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\r\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> {\r\n            if(Math.abs(a-x) == Math.abs(b-x))\r\n                return Integer.compare(a,b);\r\n            else \r\n                return Integer.compare(Math.abs(a-x),Math.abs(b-x));\r\n        });\r\n\r\n        for(int n : arr){\r\n            pq.offer(n);\r\n        }\r\n\r\n        List<Integer> li = new ArrayList<>();\r\n        for(int i=0;i<k;i++)\r\n            li.add(pq.poll());\r\n\r\n        Collections.sort(li);\r\n        \r\n        return li;\r\n\r\n    }\r\n}"
  },
  {
    "id": "kth-largest-element-in-array",
    "title": "Kth Largest Element in an Array",
    "topic": "Heap",
    "difficulty": "Medium",
    "tags": "Heap",
    "statement": "Given an unsorted array of integers nums and an integer k, return the kth largest element in the array.\r\n\r\nBy kth largest element, we mean the kth largest element in the sorted order, not the kth distinct element.\r\n\r\nFollow-up: Can you solve it without sorting?\r\n\r\nExample 1:\r\n\r\nInput: nums = [2,3,1,5,4], k = 2\r\n\r\nOutput: 4\r\nExample 2:\r\n\r\nInput: nums = [2,3,1,1,5,5,4], k = 3\r\n\r\nOutput: 4",
    "solution": "class Solution {\r\n    public int findKthLargest(int[] nums, int k) {\r\n        \r\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)-> a - b);\r\n        for(int i: nums){\r\n            pq.add(i);\r\n            if(pq.size() > k){\r\n                pq.poll();\r\n            }\r\n        }\r\n        \r\n        return pq.peek();\r\n    }\r\n}\r\n\r\n\r\n// [1,2,3,4,5]"
  },
  {
    "id": "find-median-from-data-stream",
    "title": " Find Median from Data Stream",
    "topic": "Heap",
    "difficulty": "Hard",
    "tags": "Double Heap",
    "statement": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\r\n\r\nFor example, for arr = [2,3,4], the median is 3.\r\nFor example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\r\nImplement the MedianFinder class:\r\n\r\nMedianFinder() initializes the MedianFinder object.\r\nvoid addNum(int num) adds the integer num from the data stream to the data structure.\r\ndouble findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\r\n[[], [1], [2], [], [3], []]\r\nOutput\r\n[null, null, null, 1.5, null, 2.0]\r\n\r\nExplanation\r\nMedianFinder medianFinder = new MedianFinder();\r\nmedianFinder.addNum(1);    // arr = [1]\r\nmedianFinder.addNum(2);    // arr = [1, 2]\r\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\r\nmedianFinder.addNum(3);    // arr[1, 2, 3]\r\nmedianFinder.findMedian(); // return 2.0\r\n \r\n\r\nConstraints:\r\n\r\n-105 <= num <= 105\r\nThere will be at least one element in the data structure before calling findMedian.\r\nAt most 5 * 104 calls will be made to addNum and findMedian.\r\n \r\n\r\nFollow up:\r\n\r\nIf all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\r\nIf 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?",
    "solution": "class MedianFinder {\r\n\r\n    PriorityQueue<Integer> left;\r\n    PriorityQueue<Integer> right;\r\n    public MedianFinder() {\r\n        this.left = new PriorityQueue<>((a,b)-> b - a);\r\n        this.right = new PriorityQueue<>((a,b)-> a - b);\r\n    }\r\n    \r\n    public void addNum(int num) {\r\n        // both empty\r\n        if(left.isEmpty() && right.isEmpty()){\r\n            left.add(num);\r\n            return;\r\n        }\r\n\r\n        // right is empty\r\n        if(right.isEmpty()){\r\n            if(left.peek() < num){\r\n                right.add(num);\r\n            }\r\n            else {\r\n                left.add(num);\r\n            }\r\n        }\r\n        // both has element so maintain order\r\n        else if(num > left.peek()){\r\n            right.add(num);\r\n        }\r\n        else {\r\n            left.add(num);\r\n        }\r\n\r\n        // if queue is disbalanced\r\n\r\n        if(left.size() > right.size()  && left.size() - right.size() > 1){\r\n            right.add(left.poll());\r\n        }\r\n        else if(right.size() > left.size() && right.size() - left.size() > 1) {\r\n            left.add(right.poll());\r\n        }\r\n        //System.out.println(left+\",\"+right);\r\n\r\n    }\r\n    \r\n    public double findMedian() {\r\n        if(left.size() == right.size()){\r\n            return (double)(left.peek() + right.peek())/2;\r\n        }\r\n        else {\r\n            return left.size() > right.size() ? (double) left.peek() : (double) right.peek();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your MedianFinder object will be instantiated and called as such:\r\n * MedianFinder obj = new MedianFinder();\r\n * obj.addNum(num);\r\n * double param_2 = obj.findMedian();\r\n */\r\n\r\n\r\n /*\r\n[2,5,1,2,1,6,3]\r\n\r\nmax 1 2 2 \r\nmin 5\r\n\r\n\r\n\r\n */"
  },
  {
    "id": "smallest-range-covering-elemenst",
    "title": "Smallest Range Covering Elements from K Lists",
    "topic": "Heap",
    "difficulty": "Hard",
    "tags": "Heap",
    "statement": "You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.\r\n\r\nWe define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\r\nOutput: [20,24]\r\nExplanation: \r\nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\r\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\r\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\r\nExample 2:\r\n\r\nInput: nums = [[1,2,3],[1,2,3],[1,2,3]]\r\nOutput: [1,1]\r\n \r\n\r\nConstraints:\r\n\r\nnums.length == k\r\n1 <= k <= 3500\r\n1 <= nums[i].length <= 50\r\n-105 <= nums[i][j] <= 105\r\nnums[i] is sorted in non-decreasing order.",
    "solution": "class Solution {\r\n    public int[] smallestRange(List<List<Integer>> nums) {\r\n        int currMax = Integer.MIN_VALUE;\r\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] - b[0]);\r\n        for(int i=0;i<nums.size();i++){\r\n            currMax = Math.max(currMax,nums.get(i).get(0));\r\n            pq.add(new int[]{nums.get(i).get(0),i,0});\r\n        }\r\n\r\n        // Track the smallest range\r\n        int[] smallRange = new int[]{0, Integer.MAX_VALUE};\r\n\r\n        while(!pq.isEmpty()){            \r\n            int[] curr = pq.remove();\r\n            int currVal = curr[0], currList = curr[1], eleIdx = curr[2];\r\n            \r\n            if(currMax - currVal < smallRange[1] - smallRange[0]){\r\n                smallRange[0] = currVal;\r\n                smallRange[1] = currMax;\r\n            }\r\n\r\n            if(eleIdx + 1 < nums.get(currList).size()){\r\n                int nextVal = nums.get(currList).get(eleIdx + 1);\r\n                pq.add(new int[]{nextVal,currList,eleIdx + 1});\r\n                currMax = Math.max(currMax,nextVal);\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n        }\r\n\r\n        return smallRange;\r\n        \r\n    }\r\n}"
  },
  {
    "id": "design-twitter",
    "title": "Design Twitter",
    "topic": "Heap",
    "difficulty": "Medium",
    "tags": "Heap",
    "statement": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\r\n\r\nImplement the Twitter class:\r\n\r\nTwitter() Initializes your twitter object.\r\nvoid postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\r\nList<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\r\nvoid follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\r\nvoid unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\r\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\r\nOutput\r\n[null, null, [5], null, null, [6, 5], null, [5]]\r\n\r\nExplanation\r\nTwitter twitter = new Twitter();\r\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\r\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\r\ntwitter.follow(1, 2);    // User 1 follows user 2.\r\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\r\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\r\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\r\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.",
    "solution": "class Tweets {\r\n    int tweetId;\r\n    int time;\r\n    public Tweets(int tweet, int time){\r\n        this.tweetId = tweet;\r\n        this.time = time;\r\n    }\r\n\r\n    public String toString(){\r\n        return \"Tweet: \"+tweetId;\r\n    }\r\n}\r\nclass Twitter {\r\n    HashMap<Integer,HashSet<Integer>> followers;\r\n    HashMap<Integer,List<Tweets>> tweets;\r\n    int time =1;\r\n    public Twitter() {\r\n        this.followers = new HashMap<Integer,HashSet<Integer>>();\r\n        this.tweets = new HashMap<Integer,List<Tweets>>();\r\n    }\r\n    \r\n    public void postTweet(int userId, int tweetId) {\r\n        if(tweets.containsKey(userId)){\r\n            tweets.get(userId).add(new Tweets(tweetId,++time));\r\n        }\r\n        else {\r\n            List<Tweets> t = new ArrayList<>();\r\n            t.add(new Tweets(tweetId,++time));\r\n            tweets.put(userId,t);\r\n        }\r\n        //System.out.println(tweets);\r\n    }\r\n    \r\n    public List<Integer> getNewsFeed(int userId) {\r\n        PriorityQueue<Tweets> pq = new PriorityQueue<>((a,b) -> b.time - a.time);\r\n        HashSet<Integer> hs = followers.getOrDefault(userId,new HashSet<Integer>());\r\n        for(Integer i : hs){\r\n            if(tweets.containsKey(i)){\r\n                for(Tweets t: tweets.get(i)){\r\n                    pq.add(t);\r\n                }\r\n            }\r\n        }\r\n\r\n        if(tweets.containsKey(userId)){\r\n            for(Tweets t: tweets.get(userId)){\r\n                    pq.add(t);\r\n            }\r\n        }\r\n\r\n        \r\n\r\n        List<Integer> output = new ArrayList<>();\r\n        int i = 0;\r\n        while(!pq.isEmpty() && i < 10){\r\n            output.add(pq.poll().tweetId);\r\n            i++;\r\n        }\r\n\r\n        return output;\r\n    }\r\n    \r\n    public void follow(int followerId, int followeeId) {\r\n        if(followers.containsKey(followerId)){\r\n            followers.get(followerId).add(followeeId);\r\n        }\r\n        else {\r\n            HashSet<Integer> hs = new HashSet<>();\r\n            hs.add(followeeId);\r\n            followers.put(followerId,hs);\r\n        }\r\n        //System.out.println(followers);\r\n    }\r\n    \r\n    public void unfollow(int followerId, int followeeId) {\r\n        if(followers.containsKey(followerId)){\r\n            followers.get(followerId).remove(followeeId);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your Twitter object will be instantiated and called as such:\r\n * Twitter obj = new Twitter();\r\n * obj.postTweet(userId,tweetId);\r\n * List<Integer> param_2 = obj.getNewsFeed(userId);\r\n * obj.follow(followerId,followeeId);\r\n * obj.unfollow(followerId,followeeId);\r\n */"
  },
  {
    "id": "implement-trie",
    "title": "Implement Trie (Prefix Tree)",
    "topic": "Trie",
    "difficulty": "Medium",
    "tags": "Trie",
    "statement": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\r\n\r\nImplement the Trie class:\r\n\r\nTrie() Initializes the trie object.\r\nvoid insert(String word) Inserts the string word into the trie.\r\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\r\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\r\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\r\nOutput\r\n[null, null, true, false, true, null, true]\r\n\r\nExplanation\r\nTrie trie = new Trie();\r\ntrie.insert(\"apple\");\r\ntrie.search(\"apple\");   // return True\r\ntrie.search(\"app\");     // return False\r\ntrie.startsWith(\"app\"); // return True\r\ntrie.insert(\"app\");\r\ntrie.search(\"app\");     // return True\r\n \r\n\r\nConstraints:\r\n\r\n1 <= word.length, prefix.length <= 2000\r\nword and prefix consist only of lowercase English letters.\r\nAt most 3 * 104 calls in total will be made to insert, search, and startsWith.",
    "solution": "class Node {\r\n    Node[] links = new Node[26];\r\n    boolean end;\r\n\r\n    public void add(char c, Node n){\r\n        links[c-'a'] = n;\r\n    }\r\n\r\n    public boolean contains(char c){\r\n        return links[c-'a'] != null;\r\n    }\r\n\r\n    public Node get(char c){\r\n        return links[c-'a'];\r\n    }\r\n\r\n}\r\nclass Trie {\r\n    Node root;\r\n\r\n    public Trie() {\r\n        root = new Node();\r\n    }\r\n    \r\n    public void insert(String word) {\r\n        Node temp = root;\r\n        for(char c: word.toCharArray()){\r\n            if(!temp.contains(c)){\r\n                Node n = new Node();\r\n                temp.add(c,n);\r\n            }\r\n            temp = temp.get(c);\r\n        }\r\n\r\n        temp.end = true;\r\n    }\r\n    \r\n    public boolean search(String word) {\r\n        Node temp = root;\r\n        for(char c: word.toCharArray()){\r\n            if(!temp.contains(c)){\r\n                return false;\r\n            }\r\n            temp = temp.get(c);\r\n        }\r\n\r\n        return temp.end;\r\n    }\r\n    \r\n    public boolean startsWith(String prefix) {\r\n        Node temp = root;\r\n        for(char c: prefix.toCharArray()){\r\n            if(!temp.contains(c)){\r\n                return false;\r\n            }\r\n            temp = temp.get(c);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Your Trie object will be instantiated and called as such:\r\n * Trie obj = new Trie();\r\n * obj.insert(word);\r\n * boolean param_2 = obj.search(word);\r\n * boolean param_3 = obj.startsWith(prefix);\r\n */"
  },
  {
    "id": "design-add-and-search-words",
    "title": "Design Add and Search Words Data Structure",
    "topic": "Trie",
    "difficulty": "Medium",
    "tags": "Trie",
    "statement": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\r\n\r\nImplement the WordDictionary class:\r\n\r\nWordDictionary() Initializes the object.\r\nvoid addWord(word) Adds word to the data structure, it can be matched later.\r\nbool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\r\n \r\n\r\nExample:\r\n\r\nInput\r\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\r\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\r\nOutput\r\n[null,null,null,null,false,true,true,true]\r\n\r\nExplanation\r\nWordDictionary wordDictionary = new WordDictionary();\r\nwordDictionary.addWord(\"bad\");\r\nwordDictionary.addWord(\"dad\");\r\nwordDictionary.addWord(\"mad\");\r\nwordDictionary.search(\"pad\"); // return False\r\nwordDictionary.search(\"bad\"); // return True\r\nwordDictionary.search(\".ad\"); // return True\r\nwordDictionary.search(\"b..\"); // return True\r\n \r\n\r\nConstraints:\r\n\r\n1 <= word.length <= 25\r\nword in addWord consists of lowercase English letters.\r\nword in search consist of '.' or lowercase English letters.\r\nThere will be at most 2 dots in word for search queries.\r\nAt most 104 calls will be made to addWord and search.",
    "solution": " class Node {\r\n    Node[] links = new Node[26];\r\n    boolean end;\r\n\r\n    public void add(char c, Node n){\r\n        links[c-'a'] = n;\r\n    }\r\n\r\n    public boolean contains(char c){\r\n        return links[c-'a'] != null;\r\n    }\r\n\r\n    public Node get(char c){\r\n        return links[c-'a'];\r\n    }\r\n\r\n}\r\n\r\nclass WordDictionary {\r\n    Node dict;\r\n    public WordDictionary() {\r\n        this.dict = new Node();\r\n    }\r\n    \r\n    public void addWord(String word) {\r\n        Node temp = dict;\r\n        for(char c: word.toCharArray()){\r\n            if(!temp.contains(c)){\r\n                Node n = new Node();\r\n                temp.add(c,n);\r\n            }\r\n            temp = temp.get(c);\r\n        }\r\n\r\n        temp.end = true;\r\n    }\r\n\r\n    public boolean searchrec(Node temp, String word){\r\n        for(int i=0;i<word.length();i++){\r\n            char c = word.charAt(i);\r\n            if(c == '.'){\r\n                for(Node n: temp.links){\r\n                    if(n != null && searchrec(n,word.substring(i+1))) \r\n                         return true;                    \r\n                }\r\n                return false;\r\n            }\r\n            else if(temp.contains(c)){\r\n                temp = temp.get(c);\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n\r\n        }\r\n        return temp != null && temp.end;\r\n    }\r\n    \r\n    public boolean search(String word) {\r\n        Node temp = dict;\r\n        boolean ans = searchrec(temp,word); \r\n        return ans;\r\n    }\r\n}\r\n\r\n/**\r\n * Your WordDictionary object will be instantiated and called as such:\r\n * WordDictionary obj = new WordDictionary();\r\n * obj.addWord(word);\r\n * boolean param_2 = obj.search(word);\r\n */"
  },
  {
    "id": "jump-game",
    "title": "Jump Game",
    "topic": "Greedy",
    "difficulty": "Medium",
    "tags": "Greedy,DP",
    "statement": "You are given an integer array nums where each element nums[i] indicates your maximum jump length at that position.\r\n\r\nReturn true if you can reach the last index starting from index 0, or false otherwise.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,0,1,0]\r\n\r\nOutput: true\r\nExplanation: First jump from index 0 to 1, then from index 1 to 3, and lastly from index 3 to 4.\r\n\r\nExample 2:\r\n\r\nInput: nums = [1,2,1,0,1]\r\n\r\nOutput: false",
    "solution": "class Solution {\r\n    public boolean canJump(int[] nums) {\r\n        int n = nums.length;\r\n        boolean[] dp = new boolean[n];\r\n        dp[n-1] = true;\r\n        for(int i= n-2;i>=0;i--){\r\n            int temp = Math.min(nums.length, i + nums[i] + 1);\r\n            for(int j= i + 1;j< temp;j++){\r\n                if(dp[j]){\r\n                    dp[i] = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return dp[0]; \r\n    }\r\n}"
  },
  {
    "id": "jump-game-2",
    "title": "Jump Game 2",
    "topic": "Greedy",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "You are given an array of integers nums, where nums[i] represents the maximum length of a jump towards the right from index i. For example, if you are at nums[i], you can jump to any index i + j where:\r\n\r\nj <= nums[i]\r\ni + j < nums.length\r\nYou are initially positioned at nums[0].\r\n\r\nReturn the minimum number of jumps to reach the last position in the array (index nums.length - 1). You may assume there is always a valid answer.\r\n\r\nExample 1:\r\n\r\nInput: nums = [2,4,1,1,1,1]\r\n\r\nOutput: 2\r\nExplanation: Jump from index 0 to index 1, then jump from index 1 to the last index.\r\n\r\nExample 2:\r\n\r\nInput: nums = [2,1,2,1,0]\r\n\r\nOutput: 2",
    "solution": "class Solution {\r\n    public int jump(int[] nums) {\r\n        return min_jump(nums,0);\r\n    }\r\n\r\n    public int min_jump(int[] nums, int index){\r\n        if(index == nums.length - 1)\r\n            return 0;\r\n        \r\n        if(index >= nums.length)\r\n            return 1000000;\r\n\r\n        int min = 1000000;\r\n        for(int i=1;i<=nums[index];i++){\r\n            int val = 1 + min_jump(nums,index+i);\r\n            min = Math.min(min,val);\r\n        }\r\n\r\n        return min;\r\n    }\r\n}"
  },
  {
    "id": "hand-of-straight",
    "title": "Hand of Straight",
    "topic": "Greedy",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "You are given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize.\r\n\r\nYou want to rearrange the cards into groups so that each group is of size groupSize, and card values are consecutively increasing by 1.\r\n\r\nReturn true if it's possible to rearrange the cards in this way, otherwise, return false.\r\n\r\nExample 1:\r\n\r\nInput: hand = [1,2,4,2,3,5,3,4], groupSize = 4\r\n\r\nOutput: true\r\nExplanation: The cards can be rearranged as [1,2,3,4] and [2,3,4,5].\r\n\r\nExample 2:\r\n\r\nInput: hand = [1,2,3,3,4,5,6,7], groupSize = 4\r\n\r\nOutput: false\r\nExplanation: The closest we can get is [1,2,3,4] and [3,5,6,7], but the cards in the second group are not consecutive.\r\n\r\nConstraints:\r\n\r\n1 <= hand.length <= 1000\r\n0 <= hand[i] <= 1000\r\n1 <= groupSize <= hand.length",
    "solution": "class Solution {\r\n    public boolean isNStraightHand(int[] hand, int groupSize) {\r\n        int n = hand.length;\r\n        if(n % groupSize != 0)\r\n            return false;\r\n\r\n        int[] freq = new int[1001];\r\n        for(int i: hand){\r\n            freq[i]++;\r\n        }   \r\n\r\n        for(int i=0;i<1001;i++){\r\n            int currVal = freq[i];\r\n            while(currVal > 0){\r\n                int temp = i + 1;\r\n                freq[i]--;\r\n                for(int j=0;j<groupSize-1;j++){\r\n                    if(freq[temp] > 0){\r\n                        freq[temp]--;\r\n                        temp += 1;\r\n                    }\r\n                    else {\r\n                        return false;\r\n                    }\r\n                }\r\n                currVal--;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}"
  },
  {
    "id": "merge-triplets-target",
    "title": "Merge Triplets to Form Target",
    "topic": "Greedy",
    "difficulty": "Medium",
    "tags": "DP",
    "statement": "You are given a 2D array of integers triplets, where triplets[i] = [ai, bi, ci] represents the ith triplet. You are also given an array of integers target = [x, y, z] which is the triplet we want to obtain.\r\n\r\nTo obtain target, you may apply the following operation on triplets zero or more times:\r\n\r\nChoose two different triplets triplets[i] and triplets[j] and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)].\r\n* E.g. if triplets[i] = [1, 3, 1] and triplets[j] = [2, 1, 2], triplets[j] will be updated to [max(1, 2), max(3, 1), max(1, 2)] = [2, 3, 2].\r\n\r\nReturn true if it is possible to obtain target as an element of triplets, or false otherwise.\r\n\r\nExample 1:\r\n\r\nInput: triplets = [[1,2,3],[7,1,1]], target = [7,2,3]\r\n\r\nOutput: true\r\nExplanation:\r\nChoose the first and second triplets, update the second triplet to be [max(1, 7), max(2, 1), max(3, 1)] = [7, 2, 3].\r\n\r\nExample 2:\r\n\r\nInput: triplets = [[2,5,6],[1,4,4],[5,7,5]], target = [5,4,6]\r\n\r\nOutput: false",
    "solution": "public class Solution {\r\n    public boolean mergeTriplets(int[][] triplets, int[] target) {\r\n        Set<Integer> good = new HashSet<>();\r\n\r\n        for (int[] t : triplets) {\r\n            if (t[0] > target[0] || t[1] > target[1] || t[2] > target[2]) {\r\n                continue;\r\n            }\r\n            for (int i = 0; i < t.length; i++) {\r\n                if (t[i] == target[i]) {\r\n                    good.add(i);\r\n                }\r\n            }\r\n        }\r\n        return good.size() == 3;\r\n    }\r\n}"
  },
  {
    "id": "partition-labels",
    "title": " Partition Labels",
    "topic": "Greedy",
    "difficulty": "Medium",
    "tags": "Two pointers",
    "statement": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string \"ababcc\" can be partitioned into [\"abab\", \"cc\"], but partitions such as [\"aba\", \"bcc\"] or [\"ab\", \"ab\", \"cc\"] are invalid.\r\n\r\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\r\n\r\nReturn a list of integers representing the size of these parts.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"ababcbacadefegdehijhklij\"\r\nOutput: [9,7,8]\r\nExplanation:\r\nThe partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\r\nThis is a partition so that each letter appears in at most one part.\r\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.\r\nExample 2:\r\n\r\nInput: s = \"eccbbbbdec\"\r\nOutput: [10]",
    "solution": "class Solution {\r\n    public List<Integer> partitionLabels(String s) {\r\n        int n = s.length();\r\n        int[] index = new int[26];\r\n        Arrays.fill(index,-1);\r\n        List<Integer> output = new ArrayList<>();\r\n\r\n        for(int i=n-1;i>=0;i--){\r\n            if(index[s.charAt(i) - 'a'] == -1)\r\n            index[s.charAt(i) - 'a'] = i;\r\n        }\r\n\r\n        int start =0, end = 0;\r\n        for(int i=0;i<n;i++){\r\n            end = Math.max(end,index[s.charAt(i) - 'a']);\r\n\r\n            if(i == end){\r\n                output.add(end - start + 1);\r\n                start = i + 1;\r\n                end = 0;\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n}\r\n"
  },
  {
    "id": "valid-paranthesis-string",
    "title": "Valid Parenthesis String",
    "topic": "Greedy",
    "difficulty": "Medium",
    "tags": "Stack",
    "statement": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\r\n\r\nThe following rules define a valid string:\r\n\r\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\r\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\r\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\r\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"()\"\r\nOutput: true\r\nExample 2:\r\n\r\nInput: s = \"(*)\"\r\nOutput: true\r\nExample 3:\r\n\r\nInput: s = \"(*))\"\r\nOutput: true",
    "solution": "class Solution {\r\n    public boolean checkValidString(String s) {\r\n        Stack<Integer> leftpar = new Stack<>();\r\n        Stack<Integer> stars = new Stack<>();\r\n\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i) == '(')\r\n                leftpar.push(i);\r\n            \r\n            else if(s.charAt(i) == '*')\r\n                stars.push(i);\r\n\r\n            else {\r\n                if(!leftpar.isEmpty())\r\n                    leftpar.pop();\r\n                else if(!stars.isEmpty())\r\n                    stars.pop();\r\n                else\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        System.out.println(leftpar);\r\n\r\n        while(!leftpar.isEmpty() && !stars.isEmpty()){\r\n            if(leftpar.pop() > stars.pop())\r\n                return false;  // if ( comes after *\r\n        }\r\n\r\n        return leftpar.isEmpty();\r\n\r\n\r\n    }\r\n}"
  },
  {
    "id": "search-in-2d-matrix",
    "title": "Search a 2D Matrix",
    "topic": "Binary Search",
    "difficulty": "Medium",
    "tags": "Binary Search",
    "statement": "You are given an m x n integer matrix matrix with the following two properties:\r\n\r\nEach row is sorted in non-decreasing order.\r\nThe first integer of each row is greater than the last integer of the previous row.\r\nGiven an integer target, return true if target is in matrix or false otherwise.\r\n\r\nYou must write a solution in O(log(m * n)) time complexity.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\r\nOutput: true\r\nExample 2:\r\n\r\n\r\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\r\nOutput: false\r\n ",
    "solution": "class Solution {\r\n    public boolean searchMatrix(int[][] matrix, int target) {\r\n        int row = matrix.length;\r\n        int col = matrix[0].length;\r\n\r\n        int top =0, bottom = row -1;\r\n        while(top <= bottom){\r\n            int mid = (top + bottom) / 2;\r\n            if(matrix[mid][0] > target){\r\n                bottom = mid - 1;\r\n            }\r\n            else if (matrix[mid][col -1] < target){\r\n                top = mid + 1;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        int k = (top + bottom) / 2; \r\n        int left =0, right = col -1;\r\n\r\n        while(left <= right){\r\n            int mid = (left + right) / 2;\r\n            if(matrix[k][mid] == target)\r\n                return true;\r\n            else if(matrix[k][mid] > target){\r\n                right = mid -1;\r\n            }\r\n            else {\r\n                left = left + 1;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}"
  },
  {
    "id": "koko-eating-banana",
    "title": "Koko Eating Bananas",
    "topic": "Binary Search",
    "difficulty": "Medium",
    "tags": "Binary Search",
    "statement": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\r\n\r\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\r\n\r\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\r\n\r\nReturn the minimum integer k such that she can eat all the bananas within h hours.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: piles = [3,6,7,11], h = 8\r\nOutput: 4\r\nExample 2:\r\n\r\nInput: piles = [30,11,23,4,20], h = 5\r\nOutput: 30\r\nExample 3:\r\n\r\nInput: piles = [30,11,23,4,20], h = 6\r\nOutput: 23",
    "solution": "class Solution {\r\n    public int minEatingSpeed(int[] piles, int h) {\r\n        int n = piles.length;\r\n        int max = Integer.MIN_VALUE;\r\n        for(int i=0;i<n;i++){\r\n            max = Math.max(max,piles[i]);\r\n        }\r\n\r\n        int left = 1, right = max;\r\n        int answer = 0;\r\n        while(left <= right){\r\n            int mid = (left + right) / 2;\r\n            if(canEat(piles,mid,h)){\r\n                answer = mid;\r\n                right = mid - 1;\r\n            }\r\n            else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return answer;\r\n    }\r\n\r\n    public boolean canEat(int[] piles, int k, int h){\r\n\r\n        for(int i=0;i<piles.length;i++){\r\n            if(piles[i] < k){\r\n                h = h - 1;\r\n            }\r\n            else {\r\n                int temp = piles[i] / k;\r\n                int rest = piles[i] % k != 0 ? 1 : 0;\r\n                h = h - (temp + rest);\r\n            }\r\n            if(h < 0)\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}"
  },
  {
    "id": "find-minimum-rotated-sorted-array",
    "title": "Find Minimum in Rotated Sorted Array",
    "topic": "Binary Search",
    "difficulty": "Medium",
    "tags": "Binary Search",
    "statement": "You are given an array of length n which was originally sorted in ascending order. It has now been rotated between 1 and n times. For example, the array nums = [1,2,3,4,5,6] might become:\r\n\r\n[3,4,5,6,1,2] if it was rotated 4 times.\r\n[1,2,3,4,5,6] if it was rotated 6 times.\r\nNotice that rotating the array 4 times moves the last four elements of the array to the beginning. Rotating the array 6 times produces the original array.\r\n\r\nAssuming all elements in the rotated sorted array nums are unique, return the minimum element of this array.\r\n\r\nA solution that runs in O(n) time is trivial, can you write an algorithm that runs in O(log n) time?\r\n\r\nExample 1:\r\n\r\nInput: nums = [3,4,5,6,1,2]\r\n\r\nOutput: 1\r\nExample 2:\r\n\r\nInput: nums = [4,5,0,1,2,3]\r\n\r\nOutput: 0\r\nExample 3:\r\n\r\nInput: nums = [4,5,6,7]\r\n\r\nOutput: 4",
    "solution": "class Solution {\r\n    public int findMin(int[] nums) {\r\n        int n = nums.length;\r\n\r\n        int left =0, right = n -1;\r\n        while(left <= right){\r\n            int mid = (left + right) / 2;\r\n            \r\n            if(nums[mid] > nums[right]){\r\n                left = mid + 1;\r\n            }\r\n            else if(nums[left] > nums[mid]){\r\n                right = mid;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n\r\n        }\r\n        return nums[left];\r\n    }\r\n}"
  },
  {
    "id": "search-in-rotated-sorted-array",
    "title": "Search in Rotated Sorted Array",
    "topic": "Binary Search",
    "difficulty": "Medium",
    "tags": "Binary Search",
    "statement": "You are given an array of length n which was originally sorted in ascending order. It has now been rotated between 1 and n times. For example, the array nums = [1,2,3,4,5,6] might become:\r\n\r\n[3,4,5,6,1,2] if it was rotated 4 times.\r\n[1,2,3,4,5,6] if it was rotated 6 times.\r\nGiven the rotated sorted array nums and an integer target, return the index of target within nums, or -1 if it is not present.\r\n\r\nYou may assume all elements in the sorted rotated array nums are unique,\r\n\r\nA solution that runs in O(n) time is trivial, can you write an algorithm that runs in O(log n) time?\r\n\r\nExample 1:\r\n\r\nInput: nums = [3,4,5,6,1,2], target = 1\r\n\r\nOutput: 4\r\nExample 2:\r\n\r\nInput: nums = [3,5,6,0,1,2], target = 4\r\n\r\nOutput: -1",
    "solution": "public class Solution {\r\n    public int search(int[] nums, int target) {\r\n        int l = 0, r = nums.length - 1;\r\n\r\n        while (l < r) {\r\n            int m = (l + r) / 2;\r\n            if (nums[m] > nums[r]) {\r\n                l = m + 1;\r\n            } else {\r\n                r = m;\r\n            }\r\n        }\r\n\r\n        int pivot = l;\r\n\r\n        int result = binarySearch(nums, target, 0, pivot - 1);\r\n        if (result != -1) {\r\n            return result;\r\n        }\r\n\r\n        return binarySearch(nums, target, pivot, nums.length - 1);\r\n    }\r\n\r\n    public int binarySearch(int[] nums, int target, int left, int right) {\r\n        while (left <= right) {\r\n            int mid = (left + right) / 2;\r\n            if (nums[mid] == target) {\r\n                return mid;\r\n            } else if (nums[mid] < target) {\r\n                left = mid + 1;\r\n            } else {\r\n                right = mid - 1;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}"
  },
  {
    "id": "time-based-key-value-store",
    "title": "Time Based Key-Value Store",
    "topic": "Binary Search",
    "difficulty": "Medium",
    "tags": "Binary Search",
    "statement": "Implement a time-based key-value data structure that supports:\r\n\r\nStoring multiple values for the same key at specified time stamps\r\nRetrieving the key's value at a specified timestamp\r\nImplement the TimeMap class:\r\n\r\nTimeMap() Initializes the object.\r\nvoid set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp.\r\nString get(String key, int timestamp) Returns the most recent value of key if set was previously called on it and the most recent timestamp for that key prev_timestamp is less than or equal to the given timestamp (prev_timestamp <= timestamp). If there are no values, it returns \"\".\r\nNote: For all calls to set, the timestamps are in strictly increasing order.\r\n\r\nExample 1:\r\n\r\nInput:\r\n[\"TimeMap\", \"set\", [\"alice\", \"happy\", 1], \"get\", [\"alice\", 1], \"get\", [\"alice\", 2], \"set\", [\"alice\", \"sad\", 3], \"get\", [\"alice\", 3]]\r\n\r\nOutput:\r\n[null, null, \"happy\", \"happy\", null, \"sad\"]\r\n\r\nExplanation:\r\nTimeMap timeMap = new TimeMap();\r\ntimeMap.set(\"alice\", \"happy\", 1);  // store the key \"alice\" and value \"happy\" along with timestamp = 1.\r\ntimeMap.get(\"alice\", 1);           // return \"happy\"\r\ntimeMap.get(\"alice\", 2);           // return \"happy\", there is no value stored for timestamp 2, thus we return the value at timestamp 1.\r\ntimeMap.set(\"alice\", \"sad\", 3);    // store the key \"alice\" and value \"sad\" along with timestamp = 3.\r\ntimeMap.get(\"alice\", 3);           // return \"sad\"",
    "solution": "class keyvault {\r\n    String value;\r\n    int time;\r\n    public keyvault(String value, int time){\r\n        this.value = value;\r\n        this.time = time;\r\n    }\r\n}\r\nclass TimeMap {\r\n    HashMap<String,List<keyvault>> map;\r\n    public TimeMap() {\r\n        map = new HashMap<>();\r\n    }\r\n    \r\n    public void set(String key, String value, int timestamp) {\r\n        keyvault k = new keyvault(value,timestamp);\r\n        if(map.containsKey(key)){\r\n            map.get(key).add(k);\r\n        }\r\n        else {\r\n            List<keyvault> li = new ArrayList<>();\r\n            li.add(k);\r\n            map.put(key,li);\r\n        }\r\n    }\r\n    \r\n    public String get(String key, int timestamp) {\r\n        List<keyvault> list = map.get(key);\r\n        if(list == null){\r\n            return \"\";\r\n        }\r\n        int l =0, r = list.size() -1 ;\r\n        String res = \"\";\r\n        while(l <= r){\r\n            int mid = (l+r)/2;\r\n            if(list.get(mid).time <= timestamp ){\r\n                res = list.get(mid).value;\r\n                l = mid + 1;\r\n            }\r\n            else {\r\n                r = mid -1 ;\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n}"
  },
  {
    "id": "find-the-closest-palindrome",
    "title": "Find the Closest Palindrome",
    "topic": "String",
    "difficulty": "Hard",
    "tags": "String",
    "statement": "Given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one.\r\n\r\nThe closest is defined as the absolute difference minimized between two integers.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: n = \"123\"\r\nOutput: \"121\"\r\nExample 2:\r\n\r\nInput: n = \"1\"\r\nOutput: \"0\"\r\nExplanation: 0 and 2 are the closest palindromes but we return the smallest which is 0.",
    "solution": "class Solution {\r\n    public String nearestPalindromic(String n) {\r\n        int len = n.length();\r\n        int i = len % 2 == 0 ? len / 2 - 1 : len / 2;\r\n        long firsthalf = Long.parseLong(n.substring(0, i + 1));\r\n        List<Long> can = new ArrayList<>();\r\n        can.add(gatpalifromhalf(firsthalf,len % 2 == 0));\r\n        can.add(gatpalifromhalf(firsthalf+1,len % 2 == 0));\r\n        can.add(gatpalifromhalf(firsthalf-1,len % 2 == 0));\r\n        can.add((long) Math.pow(10,len - 1) - 1);\r\n        can.add((long) Math.pow(10,len) + 1);\r\n        long diff = Long.MAX_VALUE, n1 = Long.parseLong(n), res =0;\r\n        for(long c : can){\r\n            if(c == n1)\r\n                continue;\r\n            if(Math.abs(c - n1) < diff){\r\n                diff = Math.abs(c - n1);\r\n                res = c;\r\n            }\r\n            else if(Math.abs(c - n1) == diff){\r\n                res = Math.min(res,c);\r\n            }\r\n        }\r\n\r\n        return String.valueOf(res);\r\n    }\r\n\r\n    // 500 will become 500,005\r\n    public Long gatpalifromhalf(long num, boolean even){\r\n        long res = num;\r\n        if(!even){\r\n            num = num/10;\r\n        }\r\n        while(num > 0){\r\n            res = res * 10 + (num % 10);\r\n            num = num / 10;\r\n        }\r\n        return res;\r\n    }\r\n}"
  },
  {
    "id": "invert-binary-tree",
    "title": "Invert Binary Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "tags": "Tree",
    "statement": "Given the root of a binary tree, invert the tree, and return its root.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [4,2,7,1,3,6,9]\r\nOutput: [4,7,2,9,6,3,1]\r\nExample 2:\r\n\r\n\r\nInput: root = [2,1,3]\r\nOutput: [2,3,1]\r\nExample 3:\r\n\r\nInput: root = []\r\nOutput: []",
    "solution": "class Solution {\r\n    public TreeNode invertTree(TreeNode root) {\r\n        return invert(root);\r\n    }\r\n\r\n    public TreeNode invert(TreeNode root){\r\n        if(root == null)\r\n            return root;\r\n        \r\n        TreeNode output = new TreeNode(root.val);\r\n\r\n        output.left = invert(root.right);\r\n        output.right = invert(root.left);\r\n\r\n        return output;\r\n    }\r\n}"
  },
  {
    "id": "balanced=binary-tree",
    "title": "Balanced Binary Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "tags": "Tree",
    "statement": "Given a binary tree, determine if it is height-balanced.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [3,9,20,null,null,15,7]\r\nOutput: true\r\nExample 2:\r\n\r\n\r\nInput: root = [1,2,2,3,3,null,null,4,4]\r\nOutput: false\r\nExample 3:\r\n\r\nInput: root = []\r\nOutput: true",
    "solution": "class Solution {\r\n    public boolean isBalanced(TreeNode root) {\r\n        if(root == null)\r\n            return true;\r\n        \r\n        int left = height(root.left);\r\n        int right = height(root.right);\r\n\r\n        return Math.abs(left - right) < 2 && isBalanced(root.left) && isBalanced(root.right);\r\n\r\n    }\r\n\r\n    public int height(TreeNode root){\r\n        if(root == null)\r\n            return 0;\r\n        \r\n        return Math.max(height(root.left) + 1, height(root.right) + 1);\r\n    }\r\n}"
  },
  {
    "id": "diameter-of-binary-tree",
    "title": "Diameter of Binary Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "tags": "Tree",
    "statement": "Given the root of a binary tree, return the length of the diameter of the tree.\r\n\r\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\r\n\r\nThe length of a path between two nodes is represented by the number of edges between them.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [1,2,3,4,5]\r\nOutput: 3\r\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\r\nExample 2:\r\n\r\nInput: root = [1,2]\r\nOutput: 1",
    "solution": "class Solution {\r\n    int diameter;\r\n    public int diameterOfBinaryTree(TreeNode root) {\r\n        diameter = 1;\r\n        getDiameter(root);\r\n        return diameter-1;\r\n    }\r\n    \r\n    public int getDiameter(TreeNode root){\r\n        if(root==null)\r\n            return 0;\r\n        \r\n        int left = getDiameter(root.left);\r\n        int right = getDiameter(root.right);\r\n        \r\n        diameter = Math.max(diameter,left+right+1);\r\n        \r\n        return Math.max(left,right)+1;\r\n        \r\n    }\r\n}"
  },
  {
    "id": "maximum-depth-of-binary-tre",
    "title": "Maximum Depth of Binary Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "tags": "Tree",
    "statement": "Given the root of a binary tree, return its maximum depth.\r\n\r\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [3,9,20,null,null,15,7]\r\nOutput: 3\r\nExample 2:\r\n\r\nInput: root = [1,null,2]\r\nOutput: 2",
    "solution": "class Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null)\r\n            return 0;\r\n        \r\n        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;\r\n    }\r\n}"
  },
  {
    "id": "same-tree",
    "title": "Same Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "tags": "Tree",
    "statement": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\r\n\r\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: p = [1,2,3], q = [1,2,3]\r\nOutput: true\r\nExample 2:\r\n\r\n\r\nInput: p = [1,2], q = [1,null,2]\r\nOutput: false\r\nExample 3:\r\n\r\n\r\nInput: p = [1,2,1], q = [1,1,2]\r\nOutput: false",
    "solution": "class Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null)\r\n            return true;\r\n        \r\n        if(p != null && q == null || p == null && q != null)\r\n            return false;\r\n\r\n        return p.val == q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\r\n            \r\n    }\r\n}"
  },
  {
    "id": "symmetric-tree",
    "title": " Symmetric Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "tags": "Tree",
    "statement": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [1,2,2,3,4,4,3]\r\nOutput: true\r\nExample 2:\r\n\r\n\r\nInput: root = [1,2,2,null,3,null,3]\r\nOutput: false\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in the tree is in the range [1, 1000].\r\n-100 <= Node.val <= 100\r\n \r\n\r\nFollow up: Could you solve it both recursively and iteratively?",
    "solution": "class Solution {\r\n    public boolean isSymmetric(TreeNode root) {\r\n        if(root == null) \r\n            return true;\r\n\r\n        return issym(root.left, root.right);\r\n    }\r\n\r\n    public boolean issym(TreeNode left, TreeNode right){\r\n        if(left == null && right == null)\r\n            return true;\r\n        \r\n        if(left == null || right == null)\r\n            return false;\r\n\r\n        if(left.val != right.val)\r\n            return false;\r\n\r\n        return issym(left.left,right.right) && issym(left.right,right.left);\r\n    }\r\n}"
  },
  {
    "id": "subtree-of-another-tree",
    "title": "Subtree of Another Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "tags": "Tree",
    "statement": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\r\n\r\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\r\nOutput: true\r\nExample 2:\r\n\r\n\r\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\r\nOutput: false",
    "solution": "class Solution {\r\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {        \r\n        if(root == null && subRoot == null)\r\n            return true;\r\n        \r\n        if(root == null)\r\n            return false;\r\n\r\n        if(isSameTree(root,subRoot))\r\n            return true;\r\n\r\n        return isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot);\r\n        \r\n    }\r\n\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null)\r\n            return true;\r\n        if(p == null || q == null)\r\n            return false;\r\n        return p.val == q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\r\n    }\r\n}"
  },
  {
    "id": "binary-tree-level-order-traversal",
    "title": "Binary Tree Level Order Traversal",
    "topic": "Tree",
    "difficulty": "Medium",
    "tags": "Tree",
    "statement": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [3,9,20,null,null,15,7]\r\nOutput: [[3],[9,20],[15,7]]\r\nExample 2:\r\n\r\nInput: root = [1]\r\nOutput: [[1]]\r\nExample 3:\r\n\r\nInput: root = []\r\nOutput: []",
    "solution": "class Solution {\r\n    public List<List<Integer>> levelOrder(TreeNode root) {\r\n        if(root == null)\r\n            return new ArrayList<>();\r\n        \r\n        Queue<TreeNode> q = new LinkedList<>();\r\n        List<List<Integer>> output  = new ArrayList<>();\r\n        q.add(root);\r\n        while(!q.isEmpty()){\r\n            int size = q.size();\r\n            List<Integer> temp = new ArrayList<>();\r\n            for(int i=0;i<size;i++){\r\n                TreeNode t = q.remove();\r\n                if(t.left != null)\r\n                    q.add(t.left);\r\n                if(t.right != null)\r\n                    q.add(t.right);\r\n                temp.add(t.val);\r\n            }\r\n            output.add(temp);\r\n        }\r\n\r\n        return output;\r\n    }\r\n}"
  },
  {
    "id": "binary-tree-right-side-voiew",
    "title": "Binary Tree Right Side View",
    "topic": "Tree",
    "difficulty": "Medium",
    "tags": "Tree",
    "statement": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: root = [1,2,3,null,5,null,4]\r\n\r\nOutput: [1,3,4]\r\n\r\nExplanation:\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput: root = [1,2,3,4,null,null,null,5]\r\n\r\nOutput: [1,3,4,5]\r\n\r\nExplanation:\r\n\r\n\r\n\r\nExample 3:\r\n\r\nInput: root = [1,null,3]\r\n\r\nOutput: [1,3]\r\n\r\nExample 4:\r\n\r\nInput: root = []\r\n\r\nOutput: []",
    "solution": "class Solution {\r\n    public List<Integer> rightSideView(TreeNode root) {\r\n        List<Integer> output = new ArrayList<>();\r\n        if(root == null)\r\n            return output;\r\n        Queue<TreeNode> q = new LinkedList<>();\r\n        q.add(root);\r\n        while(!q.isEmpty()){\r\n            int size = q.size();\r\n            TreeNode temp = null;\r\n            for(int i=0;i<size;i++){\r\n                temp = q.poll();\r\n                if(temp.left != null)\r\n                    q.add(temp.left);\r\n                if(temp.right != null)\r\n                    q.add(temp.right);\r\n            }\r\n            output.add(temp.val);\r\n        }\r\n\r\n        return output;\r\n    }\r\n}"
  },
  {
    "id": "lowest-common-ancestor-binary-tree",
    "title": "Lowest Common Ancestor of a Binary Tree",
    "topic": "Tree",
    "difficulty": "Medium",
    "tags": "Tree",
    "statement": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\r\n\r\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\r\nOutput: 3\r\nExplanation: The LCA of nodes 5 and 1 is 3.\r\nExample 2:\r\n\r\n\r\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\r\nOutput: 5\r\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\r\nExample 3:\r\n\r\nInput: root = [1,2], p = 1, q = 2\r\nOutput: 1\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in the tree is in the range [2, 105].\r\n-109 <= Node.val <= 109\r\nAll Node.val are unique.\r\np != q\r\np and q will exist in the tree.",
    "solution": "class Solution {\r\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\r\n        return dfs(root,p,q);\r\n    }\r\n\r\n    public TreeNode dfs(TreeNode root,TreeNode p,TreeNode q){\r\n        if(root == null)\r\n            return null;\r\n        \r\n        if(root.val == p.val || root.val == q.val){\r\n            return root;\r\n        }\r\n\r\n        TreeNode left = dfs(root.left,p,q);\r\n        TreeNode right = dfs(root.right,p,q);\r\n\r\n        if(left != null && right != null)\r\n            return root;\r\n\r\n\r\n        if(left == null)\r\n            return right;\r\n        else \r\n            return left;\r\n    }\r\n}"
  },
  {
    "id": "minimum-edge-reversal-so-every-node",
    "title": "Minimum Edge Reversals So Every Node Is Reachable",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "DFS/BFS",
    "statement": "There is a simple directed graph with n nodes labeled from 0 to n - 1. The graph would form a tree if its edges were bi-directional.\r\n\r\nYou are given an integer n and a 2D integer array edges, where edges[i] = [ui, vi] represents a directed edge going from node ui to node vi.\r\n\r\nAn edge reversal changes the direction of an edge, i.e., a directed edge going from node ui to node vi becomes a directed edge going from node vi to node ui.\r\n\r\nFor every node i in the range [0, n - 1], your task is to independently calculate the minimum number of edge reversals required so it is possible to reach any other node starting from node i through a sequence of directed edges.\r\n\r\nReturn an integer array answer, where answer[i] is the minimum number of edge reversals required so it is possible to reach any other node starting from node i through a sequence of directed edges.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\n\r\nInput: n = 4, edges = [[2,0],[2,1],[1,3]]\r\nOutput: [1,1,0,2]\r\nExplanation: The image above shows the graph formed by the edges.\r\nFor node 0: after reversing the edge [2,0], it is possible to reach any other node starting from node 0.\r\nSo, answer[0] = 1.\r\nFor node 1: after reversing the edge [2,1], it is possible to reach any other node starting from node 1.\r\nSo, answer[1] = 1.\r\nFor node 2: it is already possible to reach any other node starting from node 2.\r\nSo, answer[2] = 0.\r\nFor node 3: after reversing the edges [1,3] and [2,1], it is possible to reach any other node starting from node 3.\r\nSo, answer[3] = 2.\r\nExample 2:\r\n\r\n\r\n\r\nInput: n = 3, edges = [[1,2],[2,0]]\r\nOutput: [2,0,1]\r\nExplanation: The image above shows the graph formed by the edges.\r\nFor node 0: after reversing the edges [2,0] and [1,2], it is possible to reach any other node starting from node 0.\r\nSo, answer[0] = 2.\r\nFor node 1: it is already possible to reach any other node starting from node 1.\r\nSo, answer[1] = 0.\r\nFor node 2: after reversing the edge [1, 2], it is possible to reach any other node starting from node 2.\r\nSo, answer[2] = 1.\r\n \r\n\r\nConstraints:\r\n\r\n2 <= n <= 105\r\nedges.length == n - 1\r\nedges[i].length == 2\r\n0 <= ui == edges[i][0] < n\r\n0 <= vi == edges[i][1] < n\r\nui != vi\r\nThe input is generated such that if the edges were bi-directional, the graph would be a tree.",
    "solution": "class Path {\r\n    int node;\r\n    int value;\r\n    public Path(int n, int v){\r\n        node = n;\r\n        value = v;\r\n    }\r\n}\r\nclass Solution {\r\n\r\n    public int[] minEdgeReversals(int n, int[][] edges) {\r\n        List<List<Path>> li = new ArrayList<>();\r\n\r\n        for(int i=0;i<n;i++){\r\n            li.add(new ArrayList<Path>());\r\n        }\r\n\r\n        for(int[] e : edges){\r\n            int u = e[0];\r\n            int v = e[1];\r\n            li.get(u).add(new Path(v,0));\r\n            // reverse edge with cost of 1 \r\n            li.get(v).add(new Path(u,1));\r\n        }\r\n\r\n        int[] output = new int[n];\r\n\r\n        boolean[] visited = new boolean[n];\r\n        Arrays.fill(visited,false);\r\n        // find distance from 0\r\n        output[0] = dfs(li,visited,0);\r\n\r\n        Arrays.fill(visited,false);\r\n        reroute(li,visited,output,0);\r\n        return output;\r\n\r\n\r\n    }\r\n\r\n    public int dfs(List<List<Path>> adj, boolean[] visited, int n){\r\n        visited[n] = true;\r\n        int costTraversal = 0;\r\n        for(Path i: adj.get(n)){\r\n            int node = i.node;\r\n            int cost = i.value;\r\n\r\n            if(!visited[node]){\r\n                costTraversal += cost + dfs(adj,visited,node);\r\n            }\r\n        }\r\n\r\n        return costTraversal;\r\n    }\r\n\r\n    public void reroute(List<List<Path>> adj, boolean[] visited, int[] result, int n){\r\n        visited[n] = true;\r\n\r\n        for(Path p : adj.get(n)){\r\n            int nextNode = p.node;\r\n            int cost = p.value;\r\n\r\n            if(!visited[nextNode]){\r\n                int delta = (cost == 0) ? 1 : -1;\r\n                result[nextNode] = result[n] + delta;\r\n                reroute(adj,visited,result,nextNode);\r\n            }\r\n        }\r\n    }\r\n}"
  },
  {
    "id": "longest-continuous-subarray-with-diff",
    "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
    "topic": "Sliding Window",
    "difficulty": "Hard",
    "tags": "sliding window",
    "statement": "Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [8,2,4,7], limit = 4\r\nOutput: 2 \r\nExplanation: All subarrays are: \r\n[8] with maximum absolute diff |8-8| = 0 <= 4.\r\n[8,2] with maximum absolute diff |8-2| = 6 > 4. \r\n[8,2,4] with maximum absolute diff |8-2| = 6 > 4.\r\n[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.\r\n[2] with maximum absolute diff |2-2| = 0 <= 4.\r\n[2,4] with maximum absolute diff |2-4| = 2 <= 4.\r\n[2,4,7] with maximum absolute diff |2-7| = 5 > 4.\r\n[4] with maximum absolute diff |4-4| = 0 <= 4.\r\n[4,7] with maximum absolute diff |4-7| = 3 <= 4.\r\n[7] with maximum absolute diff |7-7| = 0 <= 4. \r\nTherefore, the size of the longest subarray is 2.\r\nExample 2:\r\n\r\nInput: nums = [10,1,2,4,7,2], limit = 5\r\nOutput: 4 \r\nExplanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.\r\nExample 3:\r\n\r\nInput: nums = [4,2,2,2,4,4,2,2], limit = 0\r\nOutput: 3",
    "solution": "class Solution {\r\n    public int longestSubarray(int[] nums, int limit) {\r\n        PriorityQueue<int[]> min = new PriorityQueue<>((a,b) -> a[0] - b[0]);\r\n\r\n        PriorityQueue<int[]> max = new PriorityQueue<>((a,b) -> b[0] - a[0]);\r\n\r\n        int left =0, max_length = 0;\r\n\r\n        for(int right=0;right<nums.length;right++){\r\n            min.add(new int[]{nums[right], right});\r\n            max.add(new int[]{nums[right], right});\r\n\r\n            while(!max.isEmpty() && !min.isEmpty() && max.peek()[0] - min.peek()[0] > limit){\r\n                left = Math.min(max.peek()[1],min.peek()[1]) + 1;\r\n\r\n                while(!max.isEmpty() && max.peek()[1] < left){\r\n                    max.poll();\r\n                }\r\n\r\n                while(!min.isEmpty() && min.peek()[1] < left){\r\n                    min.poll();\r\n                }\r\n            }\r\n\r\n            max_length = Math.max(max_length,right - left + 1);\r\n        }\r\n\r\n        return max_length;\r\n    }\r\n}\r\n\r\n/*\r\n\r\nwe need to find longest subarray when absoulte diff in less than limit (for all pairs)\r\n\r\n1. use sliding window to keep track of valid window \r\n2. use minheap and maxheap to keep track of min and max value in that window \r\n3. if diff > limit, shrink/expand window \r\n4. return max length\r\n\r\n\r\n*/"
  },
  {
    "id": "word-search-2",
    "title": "Word Search II",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "Trie",
    "statement": "Given an m x n board of characters and a list of strings words, return all words on the board.\r\n\r\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\r\n\r\n ",
    "solution": "class Node {\r\n    Node node[] = new Node[26];\r\n    boolean eow;\r\n\r\n    public boolean contains(char c){\r\n        return node[c - 'a'] != null;\r\n    }\r\n\r\n    public Node get(char c){\r\n        return node[c - 'a'];\r\n    }\r\n\r\n    public void put(char c, Node n){\r\n        node[c-'a'] = n;\r\n    }\r\n}\r\n\r\nclass Solution {\r\n    HashSet<String> output = new HashSet<>();\r\n    public Node root;\r\n\r\n    public void insert(String s){\r\n        Node temp = root;\r\n        for(char c: s.toCharArray()){\r\n            if(!temp.contains(c)){\r\n                temp.put(c, new Node());\r\n            }\r\n            temp = temp.get(c);\r\n        }\r\n        temp.eow = true;\r\n    }\r\n\r\n    public boolean search(String word){\r\n        Node n = traverse(word);\r\n        return n != null && n.eow;\r\n    }\r\n\r\n    public Node traverse(String word){\r\n        Node node = root;\r\n        for (char c: word.toCharArray()){\r\n            if (!node.contains(c)){\r\n                return null;\r\n            }\r\n            node = node.get(c);\r\n        }\r\n        return node;\r\n    }\r\n\r\n\r\n    public List<String> findWords(char[][] board, String[] words) {\r\n        root = new Node();\r\n        // create trie for words string\r\n        for(String s: words){\r\n            insert(s);\r\n        }\r\n\r\n        int n = board.length;\r\n        int m = board[0].length;\r\n\r\n        // do dfs on matrix\r\n        for(int i=0;i<board.length;i++){\r\n            for(int j=0;j<board[0].length;j++){\r\n                dfs(board,i,j,n,m,root, board[i][j]+\"\");\r\n            }\r\n        }\r\n\r\n        List<String> out = new ArrayList<>(output);\r\n\r\n        return out;\r\n\r\n\r\n    }\r\n\r\n    public void dfs(char[][] board, int i, int j, int n, int m, Node root, String s){\r\n\r\n        if(board[i][j] == '*' || !root.contains(board[i][j]))\r\n            return;\r\n        \r\n        root = root.get(board[i][j]);\r\n        \r\n        if(root.eow){\r\n            output.add(s);\r\n        }\r\n\r\n        int[] r = {-1,0,1,0};\r\n        int[] c = { 0,-1,0,1};\r\n\r\n        for(int k =0;k<4;k++){\r\n            int row = i + r[k];\r\n            int col = j + c[k];\r\n\r\n            if(row >= 0 && row < n && col >= 0 && col < m && board[row][col] != '*'){\r\n                char ch = board[i][j];\r\n                board[i][j] = '*';\r\n                if(root.contains(board[row][col]))\r\n                {\r\n                    dfs(board,row,col,n,m,root,s+board[row][col]+\"\");\r\n                }\r\n                board[i][j] = ch;\r\n            }\r\n        }\r\n\r\n    }\r\n}"
  },
  {
    "id": "design-hit-counter",
    "title": "Design Hit Counter",
    "topic": "Queue",
    "difficulty": "Medium",
    "tags": "Queue",
    "statement": "Design a hit counter which counts the number of hits received in the past 5 minutes (i.e., the past 300 seconds).\r\n\r\nYour system should accept a timestamp parameter (in seconds granularity), and you may assume that calls are being made to the system in chronological order (i.e., timestamp is monotonically increasing). Several hits may arrive roughly at the same time.\r\n\r\nImplement the HitCounter class:\r\n\r\nHitCounter() Initializes the object of the hit counter system.\r\nvoid hit(int timestamp) Records a hit that happened at timestamp (in seconds). Several hits may happen at the same timestamp.\r\nint getHits(int timestamp) Returns the number of hits in the past 5 minutes from timestamp (i.e., the past 300 seconds).\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"HitCounter\", \"hit\", \"hit\", \"hit\", \"getHits\", \"hit\", \"getHits\", \"getHits\"]\r\n[[], [1], [2], [3], [4], [300], [300], [301]]\r\nOutput\r\n[null, null, null, null, 3, null, 4, 3]\r\n\r\nExplanation\r\nHitCounter hitCounter = new HitCounter();\r\nhitCounter.hit(1);       // hit at timestamp 1.\r\nhitCounter.hit(2);       // hit at timestamp 2.\r\nhitCounter.hit(3);       // hit at timestamp 3.\r\nhitCounter.getHits(4);   // get hits at timestamp 4, return 3.\r\nhitCounter.hit(300);     // hit at timestamp 300.\r\nhitCounter.getHits(300); // get hits at timestamp 300, return 4.\r\nhitCounter.getHits(301); // get hits at timestamp 301, return 3.\r\n \r\n\r\nConstraints:\r\n\r\n1 <= timestamp <= 2 * 109\r\nAll the calls are being made to the system in chronological order (i.e., timestamp is monotonically increasing).\r\nAt most 300 calls will be made to hit and getHits.\r\n \r\n\r\nFollow up: What if the number of hits per second could be huge? Does your design scale?",
    "solution": "class HitCounter {\r\n    private Queue<Integer> hits; \r\n\r\n    /** Initialize your data structure here. */\r\n    public HitCounter() {\r\n        this.hits = new LinkedList<Integer>();\r\n    }\r\n    \r\n    /** Record a hit.\r\n        @param timestamp - The current timestamp (in seconds granularity). */\r\n    public void hit(int timestamp) {\r\n        this.hits.add(timestamp);\r\n    }\r\n    \r\n    /** Return the number of hits in the past 5 minutes.\r\n        @param timestamp - The current timestamp (in seconds granularity). */\r\n    public int getHits(int timestamp) {\r\n        while (!this.hits.isEmpty()) {\r\n            int diff = timestamp - this.hits.peek();\r\n            if (diff >= 300) this.hits.remove();\r\n            else break;\r\n        }\r\n        return this.hits.size();\r\n    }\r\n}"
  },
  {
    "id": "design-file-system",
    "title": "Design file System",
    "topic": "Trie",
    "difficulty": "Hard",
    "tags": "Trie",
    "statement": "Design a data structure that simulates an in-memory file system.\r\n\r\nImplement the FileSystem class:\r\n\r\nFileSystem() Initializes the object of the system.\r\nList<String> ls(String path)\r\nIf path is a file path, returns a list that only contains this file's name.\r\nIf path is a directory path, returns the list of file and directory names in this directory.\r\nThe answer should in lexicographic order.\r\nvoid mkdir(String path) Makes a new directory according to the given path. The given directory path does not exist. If the middle directories in the path do not exist, you should create them as well.\r\nvoid addContentToFile(String filePath, String content)\r\nIf filePath does not exist, creates that file containing given content.\r\nIf filePath already exists, appends the given content to original content.\r\nString readContentFromFile(String filePath) Returns the content in the file at filePath.\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput\r\n[\"FileSystem\", \"ls\", \"mkdir\", \"addContentToFile\", \"ls\", \"readContentFromFile\"]\r\n[[], [\"/\"], [\"/a/b/c\"], [\"/a/b/c/d\", \"hello\"], [\"/\"], [\"/a/b/c/d\"]]\r\nOutput\r\n[null, [], null, null, [\"a\"], \"hello\"]\r\n\r\nExplanation\r\nFileSystem fileSystem = new FileSystem();\r\nfileSystem.ls(\"/\");                         // return []\r\nfileSystem.mkdir(\"/a/b/c\");\r\nfileSystem.addContentToFile(\"/a/b/c/d\", \"hello\");\r\nfileSystem.ls(\"/\");                         // return [\"a\"]\r\nfileSystem.readContentFromFile(\"/a/b/c/d\"); // return \"hello\"",
    "solution": "class Node {\r\n    Map<String, Node> children = new HashMap<>();\r\n    StringBuilder content = new StringBuilder();\r\n    boolean isFile = false;\r\n}\r\n\r\nclass FileSystem {\r\n    private final Node root = new Node();\r\n\r\n    private Node traverse(String path, boolean create){\r\n        String[] dir = path.split(\"/\");\r\n        Node curr = root;\r\n        for(int i = 1;i < dir.length; i++) {\r\n            if(!curr.children.containsKey(dir[i])){\r\n                curr.children.put(dir[i], new Node());\r\n            }\r\n            curr = curr.children.get(dir[i]);\r\n        }\r\n\r\n        return curr;\r\n    }\r\n\r\n    public List<String> ls(String path) {\r\n        Node curr = traverse(path,true);\r\n        if(!curr.isFile){\r\n            List<String> res = new ArrayList<>(curr.children.keySet());\r\n            Collections.sort(res);\r\n            return res;\r\n        }\r\n        else {\r\n            String[] parts = path.split(\"/\");\r\n            return Arrays.asList(parts[parts.length - 1]); \r\n        }\r\n    }\r\n    \r\n    public void mkdir(String path) {\r\n        traverse(path,true);\r\n    }\r\n    \r\n    public void addContentToFile(String filePath, String content) {\r\n        Node curr = traverse(filePath,true);\r\n        curr.isFile = true;\r\n        curr.content.append(content);\r\n    }\r\n    \r\n    public String readContentFromFile(String filePath) {\r\n        Node node = traverse(filePath, false);\r\n        if (node == null || !node.isFile) \r\n            return \"\"; // per problem constraints, path will exist\r\n        return node.content.toString();\r\n    }\r\n}\r\n\r\n/**\r\n * Your FileSystem object will be instantiated and called as such:\r\n * FileSystem obj = new FileSystem();\r\n * List<String> param_1 = obj.ls(path);\r\n * obj.mkdir(path);\r\n * obj.addContentToFile(filePath,content);\r\n * String param_4 = obj.readContentFromFile(filePath);\r\n */"
  },
  {
    "id": "shortest-bridge",
    "title": "Shortest bridge",
    "topic": "Graph",
    "difficulty": "Hard",
    "tags": "BFS",
    "statement": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\r\n\r\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\r\n\r\nYou may change 0's to 1's to connect the two islands to form one island.\r\n\r\nReturn the smallest number of 0's you must flip to connect the two islands.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: grid = [[0,1],[1,0]]\r\nOutput: 1\r\nExample 2:\r\n\r\nInput: grid = [[0,1,0],[0,0,0],[0,0,1]]\r\nOutput: 2\r\nExample 3:\r\n\r\nInput: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\r\nOutput: 1",
    "solution": "\r\nclass Solution {\r\n    public int shortestBridge(int[][] grid) {\r\n        int n = grid.length;\r\n\r\n        // dfs to differentiate 2 islands\r\n        boolean islandfound = false;\r\n        for(int i=0;i<n;i++){\r\n            if(islandfound)\r\n                break;\r\n            for(int j=0;j<n;j++){\r\n                if(grid[i][j] == 1)\r\n                {\r\n                    dfs(grid,i,j,n);\r\n                    islandfound = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        Queue<int[]> q = new LinkedList<>();\r\n        boolean[][] v = new boolean[n][n];\r\n        // bfs \r\n        for (int i=0;i<n;i++){\r\n            for(int j=0;j<n;j++){\r\n                if(grid[i][j] == 2){\r\n                    q.add(new int[]{i,j,0});\r\n                    v[i][j] = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        for(int i=0;i<n;i++){\r\n            for(int j=0;j<n;j++){\r\n                System.out.print(grid[i][j]+\" \");\r\n            }\r\n            System.out.println();\r\n        }\r\n\r\n        int cost =0;\r\n        int[] r = {-1,0,1,0};\r\n        int[] co = {0,1,0,-1};\r\n\r\n        while(!q.isEmpty()){\r\n            int[] c = q.poll();\r\n            System.out.println(c[0]+\",\"+c[1]);\r\n            for(int i=0;i<4;i++){\r\n                int nr = c[0] + r[i];\r\n                int nc = c[1] + co[i];\r\n                if(nr >=0 && nc >=0 && nr < n && nc < n){\r\n                    if(grid[nr][nc] == 0){\r\n                        q.add(new int[]{nr,nc,c[2]+1});\r\n                        grid[nr][nc] = -1;\r\n                    }\r\n                    else if(grid[nr][nc] == 1){\r\n                        return c[2];\r\n                    }\r\n                } \r\n            }\r\n\r\n        }\r\n        return cost;\r\n    }\r\n\r\n    public void dfs(int[][] grid, int i, int j, int n){\r\n        grid[i][j] = 2;\r\n        int[] r = {-1,0,1,0};\r\n        int[] c = {0,1,0,-1};\r\n        for(int k=0;k<4;k++){\r\n            int nr = i + r[k];\r\n            int nc = j + c[k];\r\n\r\n            if(nr >=0 && nc >=0 && nr < n && nc < n && grid[nr][nc] == 1){\r\n                dfs(grid,nr,nc,n);\r\n            }\r\n        }\r\n    }\r\n}"
  },
  {
    "id": "leftmost-column-least-one",
    "title": "Leftmost Column with at Least a One",
    "topic": "Binary Search",
    "difficulty": "Medium",
    "tags": "Binary Search",
    "statement": "A row-sorted binary matrix means that all elements are 0 or 1 and each row of the matrix is sorted in non-decreasing order.\r\n\r\nGiven a row-sorted binary matrix binaryMatrix, return the index (0-indexed) of the leftmost column with a 1 in it. If such an index does not exist, return -1.\r\n\r\nYou can't access the Binary Matrix directly. You may only access the matrix using a BinaryMatrix interface:\r\n\r\nBinaryMatrix.get(row, col) returns the element of the matrix at index (row, col) (0-indexed).\r\nBinaryMatrix.dimensions() returns the dimensions of the matrix as a list of 2 elements [rows, cols], which means the matrix is rows x cols.\r\nSubmissions making more than 1000 calls to BinaryMatrix.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.\r\n\r\nFor custom testing purposes, the input will be the entire binary matrix mat. You will not have access to the binary matrix directly.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: mat = [[0,0],[1,1]]\r\nOutput: 0\r\nExample 2:\r\n\r\n\r\nInput: mat = [[0,0],[0,1]]\r\nOutput: 1\r\nExample 3:\r\n\r\n\r\nInput: mat = [[0,0],[0,0]]\r\nOutput: -1\r\n \r\n\r\nConstraints:\r\n\r\nrows == mat.length\r\ncols == mat[i].length\r\n1 <= rows, cols <= 100\r\nmat[i][j] is either 0 or 1.\r\nmat[i] is sorted in non-decreasing order.",
    "solution": "class Solution {\r\n    public int leftMostColumnWithOne(BinaryMatrix binaryMatrix) {\r\n        int rows = binaryMatrix.dimensions().get(0);\r\n        int cols = binaryMatrix.dimensions().get(1);\r\n\r\n        // Set pointers to the top-right corner.\r\n        int currentRow = 0;\r\n        int currentCol = cols - 1;\r\n    \r\n        // Repeat the search until it goes off the grid.\r\n        while (currentRow < rows && currentCol >= 0) {\r\n            if (binaryMatrix.get(currentRow, currentCol) == 0) {\r\n                currentRow++;\r\n            } else {\r\n                currentCol--; \r\n            }\r\n        }\r\n    \r\n        // If we never left the last column, this is because it was all 0's.\r\n        return (currentCol == cols - 1) ? -1 : currentCol + 1;\r\n    }\r\n}"
  },
  {
    "id": "evaluate-division",
    "title": "Evaluate Division",
    "topic": "Graph",
    "difficulty": "Medium",
    "tags": "DFS/BFS",
    "statement": "You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\r\n\r\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\r\n\r\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\r\n\r\nNote: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\r\n\r\nNote: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\r\nOutput: [6.00000,0.50000,-1.00000,1.00000,-1.00000]\r\nExplanation: \r\nGiven: a / b = 2.0, b / c = 3.0\r\nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? \r\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\r\nnote: x is undefined => -1.0\r\nExample 2:\r\n\r\nInput: equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\r\nOutput: [3.75000,0.40000,5.00000,0.20000]\r\nExample 3:\r\n\r\nInput: equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\r\nOutput: [0.50000,2.00000,-1.00000,-1.00000]",
    "solution": "class pair {\r\n    String s;\r\n    double v;\r\n    public pair(String s, double v){\r\n        this.s = s;\r\n        this.v = v;\r\n    }\r\n}\r\nclass Solution {\r\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\r\n        HashMap<String, List<pair>> map = new HashMap<>();\r\n        double[] output = new double[queries.size()];\r\n        for(int i=0;i<equations.size();i++){\r\n            String one = equations.get(i).get(0);\r\n            String two = equations.get(i).get(1);\r\n            addnode(map,values[i],one,two);\r\n            addnode(map,1/values[i],two,one);\r\n        }\r\n        int count =0;\r\n        for(List<String> e: queries){\r\n            String start = e.get(0);\r\n            String end = e.get(1);\r\n            System.out.println(\"Processing \"+e.toString());\r\n            Queue<pair> q = new LinkedList<>();\r\n            HashSet<String> hs = new HashSet<>();\r\n\r\n            if(map.containsKey(start)){\r\n                q.add(new pair(start,1));\r\n                hs.add(start);\r\n            }\r\n            double val = -1;\r\n            while(!q.isEmpty()){\r\n                pair c = q.poll();\r\n                System.out.println(\"Processing \"+c.s+\" \"+c.v);\r\n                if(c.s.equals(end)){\r\n                    System.out.println(\"Processing final value \"+c.v);\r\n                    val = c.v;\r\n                    break;\r\n                }\r\n\r\n                List<pair> list = map.get(c.s);\r\n                if(list == null){\r\n                    val = -1;\r\n                    break;\r\n                }\r\n                \r\n                for(pair p : list){\r\n                    if(!hs.contains(p.s)){\r\n                        hs.add(p.s);\r\n                        q.add(new pair(p.s,p.v * c.v));\r\n                    }\r\n                }\r\n\r\n            }\r\n            output[count++] = val;\r\n        }\r\n\r\n        return output;\r\n\r\n    }\r\n\r\n    public void addnode(HashMap<String,List<pair>> map, double val, String key, String to){\r\n        if(map.containsKey(key)){\r\n            List<pair> list = map.get(key);\r\n            list.add(new pair(to,val));\r\n            map.put(key,list);\r\n        }\r\n        else{\r\n            List<pair> list = new ArrayList<>();\r\n            list.add(new pair(to,val));\r\n            map.put(key,list);\r\n        }\r\n    }\r\n}"
  },
  {
    "id": "preorder-inorder-tree",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "topic": "Tree",
    "difficulty": "Medium",
    "tags": "Tree",
    "statement": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\r\nOutput: [3,9,20,null,null,15,7]\r\nExample 2:\r\n\r\nInput: preorder = [-1], inorder = [-1]\r\nOutput: [-1]\r\n \r\n\r\nConstraints:\r\n\r\n1 <= preorder.length <= 3000\r\ninorder.length == preorder.length\r\n-3000 <= preorder[i], inorder[i] <= 3000\r\npreorder and inorder consist of unique values.\r\nEach value of inorder also appears in preorder.\r\npreorder is guaranteed to be the preorder traversal of the tree.\r\ninorder is guaranteed to be the inorder traversal of the tree.",
    "solution": "class Solution {\r\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\r\n        Queue<Integer> q = new LinkedList<>();\r\n\r\n        for(int i: preorder){\r\n            q.add(i);\r\n        }        \r\n\r\n        return build(q, inorder);\r\n    }\r\n\r\n    public TreeNode build(Queue<Integer> q, int[] inorder){\r\n        if(inorder.length> 0){\r\n            int index = findIndex(inorder, q.remove());\r\n\r\n            TreeNode root = new TreeNode(inorder[index]);\r\n\r\n            root.left = build(q,Arrays.copyOfRange(inorder, 0, index));\r\n            root.right = build(q,Arrays.copyOfRange(inorder, index+1, inorder.length));\r\n\r\n            return root;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public int findIndex(int[] order, int n){\r\n        for(int i=0;i<order.length;i++){\r\n            if(order[i] == n)\r\n                return i;\r\n        }\r\n        return 0;\r\n    }\r\n}"
  },
  {
    "id": "path-sum-2",
    "title": "Path Sum II",
    "topic": "Tree",
    "difficulty": "Medium",
    "tags": "Tree",
    "statement": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.\r\n\r\nA root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\r\nOutput: [[5,4,11,2],[5,8,4,5]]\r\nExplanation: There are two paths whose sum equals targetSum:\r\n5 + 4 + 11 + 2 = 22\r\n5 + 8 + 4 + 5 = 22\r\nExample 2:\r\n\r\n\r\nInput: root = [1,2,3], targetSum = 5\r\nOutput: []\r\nExample 3:\r\n\r\nInput: root = [1,2], targetSum = 0\r\nOutput: []",
    "solution": "class Solution {\r\n    List<List<Integer>> output = new ArrayList<>();\r\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\r\n        path(root,targetSum,new ArrayList<>());\r\n        return output;\r\n    }\r\n\r\n    public void path(TreeNode root, int target, List<Integer> li){\r\n        if(root == null){\r\n            return;\r\n        }\r\n\r\n        target = target - root.val;\r\n        li.add(root.val);\r\n        if(target == 0 && root.left == null && root.right == null){\r\n            output.add(new ArrayList<>(li));\r\n        }\r\n\r\n        path(root.left,target,li);\r\n        path(root.right,target,li);\r\n        if(li.size() > 0)\r\n            li.remove(li.size()-1);\r\n    }\r\n}"
  },
  {
    "id": "maximum-width-binary-tree",
    "title": "Maximum Width of Binary Tree",
    "topic": "Tree",
    "difficulty": "Medium",
    "tags": "Tree",
    "statement": "Given the root of a binary tree, return the maximum width of the given tree.\r\n\r\nThe maximum width of a tree is the maximum width among all levels.\r\n\r\nThe width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.\r\n\r\nIt is guaranteed that the answer will in the range of a 32-bit signed integer.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [1,3,2,5,3,null,9]\r\nOutput: 4\r\nExplanation: The maximum width exists in the third level with length 4 (5,3,null,9).\r\nExample 2:\r\n\r\n\r\nInput: root = [1,3,2,5,null,null,9,6,null,7]\r\nOutput: 7\r\nExplanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).\r\nExample 3:\r\n\r\n\r\nInput: root = [1,3,2,5]\r\nOutput: 2\r\nExplanation: The maximum width exists in the second level with length 2 (3,2).\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in the tree is in the range [1, 3000].\r\n-100 <= Node.val <= 100]",
    "solution": "class Node {\r\n    TreeNode n;\r\n    int index;\r\n    public Node(TreeNode n, int index){\r\n        this.n =n;\r\n        this.index = index;\r\n    }\r\n}\r\n\r\nclass Solution {\r\n    public int widthOfBinaryTree(TreeNode root) {\r\n        Queue<Node> q = new LinkedList<>();\r\n        q.add(new Node(root,0));\r\n        int width =0;\r\n\r\n        while(!q.isEmpty()){\r\n            int size = q.size();\r\n            int min=0, max=0;\r\n            for(int i=0;i<size;i++){\r\n                Node curr = q.remove();\r\n                if(i==0)\r\n                    min = curr.index;\r\n                if(i== size -1)\r\n                    max = curr.index;\r\n                \r\n                if(curr.n.left != null)\r\n                    q.add(new Node(curr.n.left, 2 * curr.index +1));\r\n                if(curr.n.right != null)\r\n                    q.add(new Node(curr.n.right, 2 * curr.index + 2));\r\n            }\r\n\r\n            width = Math.max(width, max - min +1);\r\n        }\r\n        return width;\r\n    }\r\n}"
  },
  {
    "id": "binary-tree-zigzag-level-order",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "topic": "Tree",
    "difficulty": "Medium",
    "tags": "Tree",
    "statement": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [3,9,20,null,null,15,7]\r\nOutput: [[3],[20,9],[15,7]]\r\nExample 2:\r\n\r\nInput: root = [1]\r\nOutput: [[1]]\r\nExample 3:\r\n\r\nInput: root = []\r\nOutput: []\r\n ",
    "solution": "class Solution {\r\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\r\n        List<List<Integer>> output = new ArrayList<>();\r\n        if(root == null)\r\n            return output;\r\n        Queue<TreeNode> q = new LinkedList<>();\r\n        q.add(root);\r\n        boolean order = true;\r\n        while(!q.isEmpty()){\r\n            int size = q.size();\r\n            List<Integer> temp = new ArrayList<>();\r\n            for(int i=0;i<size;i++){\r\n                TreeNode t = q.peek();\r\n                q.remove();\r\n                temp.add(t.val);\r\n                if(t.left != null)\r\n                    q.add(t.left);\r\n                if(t.right != null)\r\n                    q.add(t.right);\r\n            }\r\n\r\n            if(!order){\r\n                Collections.reverse(temp);\r\n            }\r\n            output.add(temp);\r\n            order = !order;\r\n        } \r\n\r\n        return output;\r\n    }\r\n}"
  },
  {
    "id": "path-sum-3",
    "title": "Path Sum III",
    "topic": "Tree",
    "difficulty": "Medium",
    "tags": "Tree",
    "statement": "Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.\r\n\r\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\r\nOutput: 3\r\nExplanation: The paths that sum to 8 are shown.\r\nExample 2:\r\n\r\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\r\nOutput: 3",
    "solution": "class Solution {\r\n    int count =0;\r\n    public int pathSum(TreeNode root, int targetSum) {\r\n        dfs(root, targetSum);\r\n        return count;\r\n    }\r\n\r\n    public void dfs(TreeNode root, int target){\r\n        if(root == null)\r\n            return;\r\n        count(root,target);\r\n\r\n        dfs(root.left,target);\r\n        dfs(root.right,target);\r\n    }\r\n\r\n    public void count(TreeNode root, int t){\r\n        if(root == null)\r\n            return;\r\n        \r\n        if(t - root.val == 0)\r\n        {\r\n            count++;\r\n        }\r\n\r\n        count(root.left,t-root.val);\r\n        count(root.right,t-root.val);\r\n\r\n    }\r\n}"
  },
  {
    "id": "all-nodes-distance-k-binary-tree",
    "title": "All Nodes Distance K in Binary Tree",
    "topic": "Tree",
    "difficulty": "Medium",
    "tags": "Tree",
    "statement": "Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.\r\n\r\nYou can return the answer in any order.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2\r\nOutput: [7,4,1]\r\nExplanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.\r\nExample 2:\r\n\r\nInput: root = [1], target = 1, k = 3\r\nOutput: []\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in the tree is in the range [1, 500].\r\n0 <= Node.val <= 500\r\nAll the values Node.val are unique.\r\ntarget is the value of one of the nodes in the tree.\r\n0 <= k <= 1000",
    "solution": "class Solution {\r\n    List<Integer> output = new ArrayList<>();\r\n    Map<Integer,TreeNode> map = new HashMap<>();\r\n    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {\r\n        if(root == null)\r\n            return output;\r\n        \r\n        find(root,target,null,k);\r\n        bfs(target,k);\r\n        return output;\r\n    }\r\n\r\n    public void find(TreeNode root, TreeNode target, TreeNode parent, int k){\r\n        if(root == null)\r\n            return;\r\n\r\n        if(!map.containsKey(root.val)){\r\n            map.put(root.val,parent);\r\n        }\r\n\r\n        find(root.left,target,root,k);\r\n        find(root.right,target,root,k);\r\n    }\r\n\r\n    public void bfs(TreeNode root, int k){\r\n        if(root == null)\r\n            return;\r\n        Queue<TreeNode> q = new LinkedList<>();\r\n        HashSet<Integer> hs = new HashSet<>();\r\n        q.add(root);\r\n        int val = -1;\r\n        while(!q.isEmpty()){\r\n            val++;\r\n            int size = q.size();\r\n            \r\n            for(int i=0;i<size;i++){\r\n                TreeNode temp = q.remove();\r\n                if(hs.contains(temp.val))\r\n                    continue;\r\n                hs.add(temp.val);\r\n\r\n                if(temp.left != null){\r\n                    q.add(temp.left);\r\n                }\r\n                if(temp.right != null){\r\n                    q.add(temp.right);\r\n                }\r\n                if(map.containsKey(temp.val) && map.get(temp.val) != null){\r\n                    q.add(map.get(temp.val));\r\n                }\r\n\r\n                if(val == k){\r\n                    output.add(temp.val);\r\n                }\r\n            }\r\n            \r\n        }\r\n    }\r\n}"
  },
  {
    "id": "binary-tree-maximum-path-sum",
    "title": "Binary Tree Maximum Path Sum",
    "topic": "Tree",
    "difficulty": "Medium",
    "tags": "Tree",
    "statement": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\r\n\r\nThe path sum of a path is the sum of the node's values in the path.\r\n\r\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [1,2,3]\r\nOutput: 6\r\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\r\nExample 2:\r\n\r\n\r\nInput: root = [-10,9,20,null,null,15,7]\r\nOutput: 42\r\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.",
    "solution": "class Solution {\r\n    int output = Integer.MIN_VALUE;\r\n    public int maxPathSum(TreeNode root) {\r\n        if(root == null)\r\n            return 0;     \r\n        dfs(root);\r\n        return output;\r\n    }\r\n\r\n    public int dfs(TreeNode root){        \r\n        if(root == null)\r\n            return 0; \r\n\r\n        int left = dfs(root.left);\r\n        int right = dfs(root.right);\r\n        \r\n        left = Math.max(left,0);\r\n        right = Math.max(right,0);\r\n\r\n        int total = left + right + root.val;\r\n        output = Math.max(output,total);\r\n        return Math.max(left,right) + root.val;      \r\n\r\n    }\r\n}"
  },
  {
    "id": "serialize-deseralize-binary",
    "title": "Serialize and Deserialize Binary Tree",
    "topic": "Tree",
    "difficulty": "Medium",
    "tags": "Tree",
    "statement": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\r\n\r\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\r\n\r\nClarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [1,2,3,null,null,4,5]\r\nOutput: [1,2,3,null,null,4,5]\r\nExample 2:\r\n\r\nInput: root = []\r\nOutput: []\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in the tree is in the range [0, 104].\r\n-1000 <= Node.val <= 1000\r\n ",
    "solution": "public class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        if(root == null)\r\n            return \"\";\r\n        \r\n        Queue<TreeNode> q = new LinkedList<>();\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        q.add(root);\r\n\r\n        while(!q.isEmpty()){\r\n            TreeNode temp = q.poll();\r\n\r\n            if(temp == null){\r\n                sb.append(\"# \");\r\n                continue;\r\n            }\r\n            sb.append(temp.val+\" \");\r\n            q.add(temp.left);\r\n            q.add(temp.right);\r\n        }\r\n\r\n        return sb.toString();\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        if(data.equals(\"\"))\r\n            return null;\r\n        \r\n        String[] d = data.split(\" \");\r\n\r\n        Queue<TreeNode> q = new LinkedList<>();\r\n        \r\n        TreeNode root = new TreeNode(Integer.parseInt(d[0]));\r\n        q.add(root);\r\n\r\n        for(int i=1;i<d.length;i++){\r\n            TreeNode temp = q.poll();\r\n\r\n            if(!d[i].equals(\"#\")){\r\n                TreeNode left = new TreeNode(Integer.parseInt(d[i]));\r\n                temp.left = left;\r\n                q.add(left);\r\n            }\r\n\r\n            if(!d[++i].equals(\"#\")){\r\n                TreeNode right = new TreeNode(Integer.parseInt(d[i]));\r\n                temp.right = right;\r\n                q.add(right);\r\n\r\n            }\r\n        }\r\n\r\n        return root;\r\n    }\r\n}"
  },
  {
    "id": "falling-sqaures",
    "title": "Falling Squares",
    "topic": "Arrays",
    "difficulty": "Hard",
    "tags": "Line sweep + Segment Tree",
    "statement": "There are several squares being dropped onto the X-axis of a 2D plane.\r\n\r\nYou are given a 2D integer array positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti.\r\n\r\nEach square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\r\n\r\nAfter each square is dropped, you must record the height of the current tallest stack of squares.\r\n\r\nReturn an integer array ans where ans[i] represents the height described above after dropping the ith square.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: positions = [[1,2],[2,3],[6,1]]\r\nOutput: [2,5,5]\r\nExplanation:\r\nAfter the first drop, the tallest stack is square 1 with a height of 2.\r\nAfter the second drop, the tallest stack is squares 1 and 2 with a height of 5.\r\nAfter the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\r\nThus, we return an answer of [2, 5, 5].\r\nExample 2:\r\n\r\nInput: positions = [[100,100],[200,100]]\r\nOutput: [100,100]\r\nExplanation:\r\nAfter the first drop, the tallest stack is square 1 with a height of 100.\r\nAfter the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\r\nThus, we return an answer of [100, 100].\r\nNote that square 2 only brushes the right side of square 1, which does not count as landing on it.",
    "solution": "class Solution {\r\n    public List<Integer> fallingSquares(int[][] positions) {\r\n        int n = positions.length;\r\n        List<int[]> squares = new ArrayList<>(); // [left, right,height]\r\n        List<Integer> output = new ArrayList<>();\r\n        int max_height=Integer.MIN_VALUE, prev_end = 0;\r\n\r\n        for(int i=0;i<n;i++){\r\n            \r\n            int left = positions[i][0];\r\n            int width = positions[i][1];\r\n            int right = left + width;\r\n\r\n            int base_height=0;\r\n\r\n            for(int j=0;j<squares.size();j++){\r\n                int overlapleft = squares.get(j)[0], height = squares.get(j)[2], overlapright = squares.get(j)[1];\r\n\r\n                if(Math.max(left,overlapleft) < Math.min(right,overlapright)){\r\n                    base_height = Math.max(base_height,height);\r\n                }\r\n            }\r\n            int curr_height = width + base_height;\r\n            squares.add(new int[]{left, right, curr_height});\r\n            max_height = Math.max(max_height,curr_height);\r\n            output.add(max_height);\r\n        }\r\n\r\n        return output;\r\n        \r\n    }\r\n}\r\n\r\n/*\r\n\r\n1. we need to do sweep line algorithm \r\n2. but here, we can't just maintain previous max height cause order of squares can be random and can fall at any X index\r\n3. we need to find max height in that range (thus we store max height for range left,right in squares)\r\n4. further optimization can be done using segment tree\r\n\r\n*/"
  },
  {
    "id": "my-calendar-2",
    "title": "My Calendar II",
    "topic": "Heap",
    "difficulty": "Hard",
    "tags": "Line sweep",
    "statement": "You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.\r\n\r\nA triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).\r\n\r\nThe event can be represented as a pair of integers startTime and endTime that represents a booking on the half-open interval [startTime, endTime), the range of real numbers x such that startTime <= x < endTime.\r\n\r\nImplement the MyCalendarTwo class:\r\n\r\nMyCalendarTwo() Initializes the calendar object.\r\nboolean book(int startTime, int endTime) Returns true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"]\r\n[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]\r\nOutput\r\n[null, true, true, true, false, true, true]\r\n\r\nExplanation\r\nMyCalendarTwo myCalendarTwo = new MyCalendarTwo();\r\nmyCalendarTwo.book(10, 20); // return True, The event can be booked. \r\nmyCalendarTwo.book(50, 60); // return True, The event can be booked. \r\nmyCalendarTwo.book(10, 40); // return True, The event can be double booked. \r\nmyCalendarTwo.book(5, 15);  // return False, The event cannot be booked, because it would result in a triple booking.\r\nmyCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked.\r\nmyCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.\r\n \r\n\r\nConstraints:\r\n\r\n0 <= start < end <= 109\r\nAt most 1000 calls will be made to book.",
    "solution": "class Interval {\r\n    int start;\r\n    int end;\r\n    public Interval(int start, int end){\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n}\r\nclass MyCalendarTwo {\r\n\r\n    List<Interval> booked;\r\n    List<Interval> doubleBooked;\r\n    public MyCalendarTwo() {\r\n        this.booked = new ArrayList<>();\r\n        this.doubleBooked = new ArrayList<>();\r\n    }\r\n    \r\n    public boolean book(int startTime, int endTime) {\r\n        \r\n        for(Interval i : doubleBooked){\r\n            if(overlap(i,startTime,endTime)){\r\n                return false;\r\n            }\r\n        }\r\n\r\n        for(Interval i: booked){\r\n            if(overlap(i,startTime,endTime)){\r\n                doubleBooked.add(getOverLap(i,startTime,endTime));\r\n            }\r\n        }\r\n\r\n        booked.add(new Interval(startTime,endTime));\r\n        return true;\r\n    }\r\n\r\n    public Interval getOverLap(Interval i, int start, int end){\r\n        int s = Math.max(i.start, start);\r\n        int e = Math.min(i.end, end);\r\n        return new Interval(s,e);\r\n    }\r\n\r\n\r\n    public boolean overlap(Interval i, int start, int end){\r\n        int s = Math.max(i.start, start);\r\n        int e = Math.min(i.end, end);\r\n\r\n        return (e - s > 0) ? true: false;\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyCalendarTwo object will be instantiated and called as such:\r\n * MyCalendarTwo obj = new MyCalendarTwo();\r\n * boolean param_1 = obj.book(startTime,endTime);\r\n */"
  },
  {
    "id": "skyline-problem",
    "title": "SkyLine problem",
    "topic": "Heap",
    "difficulty": "Hard",
    "tags": "Line sweep",
    "statement": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\r\n\r\nThe geometric information of each building is given in the array buildings where buildings[i] = [lefti, righti, heighti]:\r\n\r\nlefti is the x coordinate of the left edge of the ith building.\r\nrighti is the x coordinate of the right edge of the ith building.\r\nheighti is the height of the ith building.\r\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\r\n\r\nThe skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form [[x1,y1],[x2,y2],...]. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\r\n\r\nNote: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...]\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\r\nOutput: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\r\nExplanation:\r\nFigure A shows the buildings of the input.\r\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\r\nExample 2:\r\n\r\nInput: buildings = [[0,2,3],[2,5,3]]\r\nOutput: [[0,3],[5,0]]\r\n \r\n\r\nConstraints:\r\n\r\n1 <= buildings.length <= 104\r\n0 <= lefti < righti <= 231 - 1\r\n1 <= heighti <= 231 - 1\r\nbuildings is sorted by lefti in non-decreasing order.",
    "solution": "class Solution {\r\n    public List<List<Integer>> getSkyline(int[][] buildings) {\r\n        List<Integer> points = new ArrayList<>();\r\n\r\n        for(int[] b: buildings){\r\n            points.add(b[0]);\r\n            points.add(b[1]);\r\n        }\r\n\r\n        Collections.sort(points);\r\n\r\n        List<List<Integer>> output = new ArrayList<>();\r\n        int left =0, right =0, height =0, max_height=0;\r\n        for(int i: points){\r\n            max_height = 0;\r\n\r\n\r\n            // now iterate over all buildings and get max height at that point\r\n\r\n            for(int[] b : buildings){\r\n                left = b[0];\r\n                right = b[1];\r\n                height = b[2];\r\n\r\n                // we have to ignore right end of current blg for point\r\n                if( left <= i && i < right){\r\n                    max_height = Math.max(max_height,height);\r\n                }\r\n            }\r\n            // we need to record point only when its first point or height change\r\n            if(output.isEmpty() || output.get(output.size() - 1).get(1) != max_height){\r\n                output.add(Arrays.asList(i, max_height));\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n}"
  },
  {
    "id": "minimum-interval-include-each-query",
    "title": "Minimum Interval to Include Each Query",
    "topic": "Heap",
    "difficulty": "Hard",
    "tags": "Heap",
    "statement": "You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.\r\n\r\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\r\n\r\nReturn an array containing the answers to the queries.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]\r\nOutput: [3,3,1,4]\r\nExplanation: The queries are processed as follows:\r\n- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.\r\n- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.\r\n- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.\r\n- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.\r\nExample 2:\r\n\r\nInput: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]\r\nOutput: [2,-1,4,6]\r\nExplanation: The queries are processed as follows:\r\n- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.\r\n- Query = 19: None of the intervals contain 19. The answer is -1.\r\n- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.\r\n- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.",
    "solution": "class Solution {\r\n    public int[] minInterval(int[][] intervals, int[] queries) {\r\n        int n = queries.length;\r\n        int[] ans = new int[n];\r\n\r\n        // store query value + original index\r\n        int[][] q = new int[n][2];\r\n        for (int i = 0; i < n; i++) {\r\n            q[i][0] = queries[i];\r\n            q[i][1] = i;\r\n        }\r\n\r\n        Arrays.sort(q, (a, b) -> a[0] - b[0]);\r\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\r\n\r\n        PriorityQueue<int[]> pq =\r\n            new PriorityQueue<>((a, b) -> (a[1] - a[0]) - (b[1] - b[0]));\r\n\r\n        int j = 0;\r\n\r\n        for (int[] query : q) {\r\n            int val = query[0];\r\n            int idx = query[1];\r\n\r\n            // add intervals whose start <= query\r\n            while (j < intervals.length && intervals[j][0] <= val) {\r\n                pq.offer(intervals[j]);\r\n                j++;\r\n            }\r\n\r\n            // remove intervals whose end < query\r\n            while (!pq.isEmpty() && pq.peek()[1] < val) {\r\n                pq.poll();\r\n            }\r\n\r\n            ans[idx] = pq.isEmpty() ? -1 : (pq.peek()[1] - pq.peek()[0] + 1);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}"
  }
]