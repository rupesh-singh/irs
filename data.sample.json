[
  {"id":"1e0c0e9d-5c5b-4aca-8e64-111111111111","title":"Two Sum","topic":"Arrays","description":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.","solutionJava":"// HashMap approach O(n)\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        java.util.Map<Integer, Integer> map = new java.util.HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[]{ map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[]{};\n    }\n}"},
  {"id":"1e0c0e9d-5c5b-4aca-8e64-111111111112","title":"Best Time to Buy and Sell Stock","topic":"Arrays","description":"Given prices array where prices[i] is price of a given stock on day i, maximize profit by choosing a single day to buy and a different day to sell.","solutionJava":"class Solution {\n  public int maxProfit(int[] prices) {\n    int min = Integer.MAX_VALUE, ans = 0;\n    for (int p: prices) {\n      if (p < min) min = p;\n      else ans = Math.max(ans, p - min);\n    }\n    return ans;\n  }\n}"},
  {"id":"1e0c0e9d-5c5b-4aca-8e64-111111111113","title":"Contains Duplicate","topic":"Arrays","description":"Return true if any value appears at least twice in the array.","solutionJava":"class Solution {\n  public boolean containsDuplicate(int[] nums) {\n    java.util.HashSet<Integer> set = new java.util.HashSet<>();\n    for (int n: nums) if (!set.add(n)) return true;\n    return false;\n  }\n}"},
  {"id":"1e0c0e9d-5c5b-4aca-8e64-111111111114","title":"Product of Array Except Self","topic":"Arrays","description":"Return an array answer such that answer[i] is the product of all elements of nums except nums[i] without division.","solutionJava":"class Solution {\n  public int[] productExceptSelf(int[] nums) {\n    int n = nums.length; int[] out = new int[n];\n    int prefix = 1; for (int i=0;i<n;i++){ out[i]=prefix; prefix*=nums[i]; }\n    int suffix = 1; for (int i=n-1;i>=0;i--){ out[i]*=suffix; suffix*=nums[i]; }\n    return out;\n  }\n}"},
  {"id":"1e0c0e9d-5c5b-4aca-8e64-111111111115","title":"Maximum Subarray (Kadane)","topic":"Arrays","description":"Find the contiguous subarray with the largest sum.","solutionJava":"class Solution {\n  public int maxSubArray(int[] nums) {\n    int best = nums[0], cur = nums[0];\n    for (int i=1;i<nums.length;i++){ cur = Math.max(nums[i], cur+nums[i]); best = Math.max(best, cur);}\n    return best;\n  }\n}"},

  {"id":"2f0c0e9d-5c5b-4aca-8e64-222222222222","title":"Longest Substring Without Repeating Characters","topic":"Sliding Window","description":"Given a string s, find the length of the longest substring without repeating characters.","solutionJava":"class Solution {\n  public int lengthOfLongestSubstring(String s) {\n    int n = s.length(), ans = 0; int[] idx = new int[128];\n    for (int j=0,i=0;j<n;j++){ i = Math.max(idx[s.charAt(j)], i); ans = Math.max(ans, j-i+1); idx[s.charAt(j)] = j+1; }\n    return ans;\n  }\n}"},
  {"id":"2f0c0e9d-5c5b-4aca-8e64-222222222223","title":"Minimum Window Substring","topic":"Sliding Window","description":"Given s and t, return the minimum window in s that contains all characters in t.","solutionJava":"class Solution {\n  public String minWindow(String s, String t) {\n    if (t.length()>s.length()) return \"\";\n    int[] need = new int[128]; int required = 0;\n    for (char c: t.toCharArray()) if (need[c]++==0) required++;\n    int formed=0,l=0,start=0,len=Integer.MAX_VALUE; int[] have=new int[128];\n    for (int r=0;r<s.length();r++){ char c=s.charAt(r); have[c]++; if(have[c]==need[c]) formed++;\n      while(formed==required){ if(r-l+1<len){ len=r-l+1; start=l;} char lc=s.charAt(l++); if(--have[lc]<need[lc]) formed--; } }\n    return len==Integer.MAX_VALUE? \"\": s.substring(start,start+len);\n  }\n}"},
  {"id":"2f0c0e9d-5c5b-4aca-8e64-222222222224","title":"Permutation in String","topic":"Sliding Window","description":"Return true if s2 contains a permutation of s1.","solutionJava":"class Solution {\n  public boolean checkInclusion(String s1, String s2) {\n    if (s1.length()>s2.length()) return false;\n    int[] need=new int[26]; int[] win=new int[26];\n    for(char c: s1.toCharArray()) need[c-'a']++;\n    int matches=0; for (int i=0;i<s2.length();i++){ int idx=s2.charAt(i)-'a'; win[idx]++; if(win[idx]==need[idx]) matches++; if(i>=s1.length()){ int li=s2.charAt(i-s1.length())-'a'; if(win[li]==need[li]) matches--; win[li]--; } if(matches==26) return true; }\n    for(int k=0;k<26;k++) if(need[k]!=0 && win[k]==need[k]){} else if(need[k]!=0) return false;\n    return false;\n  }\n}"},
  {"id":"2f0c0e9d-5c5b-4aca-8e64-222222222225","title":"Longest Repeating Character Replacement","topic":"Sliding Window","description":"Find length of longest substring containing same letter you can get after replacing at most k characters.","solutionJava":"class Solution {\n  public int characterReplacement(String s, int k) {\n    int[] cnt=new int[26]; int l=0,max=0,ans=0;\n    for(int r=0;r<s.length();r++){ max=Math.max(max, ++cnt[s.charAt(r)-'A']); while(r-l+1-max>k){ cnt[s.charAt(l)-'A']--; l++; } ans=Math.max(ans,r-l+1);}\n    return ans;\n  }\n}"},
  {"id":"2f0c0e9d-5c5b-4aca-8e64-222222222226","title":"Sliding Window Maximum","topic":"Sliding Window","description":"Return the max of every contiguous window of size k.","solutionJava":"import java.util.*;\nclass Solution {\n  public int[] maxSlidingWindow(int[] nums, int k) {\n    int n=nums.length; int[] out=new int[n-k+1]; Deque<Integer> dq=new ArrayDeque<>();\n    for(int i=0;i<n;i++){ while(!dq.isEmpty() && dq.peekFirst()<=i-k) dq.pollFirst(); while(!dq.isEmpty() && nums[dq.peekLast()]<=nums[i]) dq.pollLast(); dq.addLast(i); if(i>=k-1) out[i-k+1]=nums[dq.peekFirst()]; }\n    return out;\n  }\n}"},

  {"id":"3a0c0e9d-5c5b-4aca-8e64-333333333333","title":"Climbing Stairs","topic":"Dynamic Programming","description":"You are climbing a staircase. It takes n steps to reach the top. Each time you can climb 1 or 2 steps. In how many distinct ways can you climb to the top?","solutionJava":"class Solution {\n  public int climbStairs(int n) {\n    if (n<=2) return n; int a=1,b=2; for(int i=3;i<=n;i++){ int c=a+b; a=b; b=c;} return b;\n  }\n}"},
  {"id":"3a0c0e9d-5c5b-4aca-8e64-333333333334","title":"House Robber","topic":"Dynamic Programming","description":"Max sum of non-adjacent numbers.","solutionJava":"class Solution {\n  public int rob(int[] nums) {\n    int prev=0, cur=0;\n    for(int n: nums){ int tmp = Math.max(cur, prev+n); prev=cur; cur=tmp; }\n    return cur;\n  }\n}"},
  {"id":"3a0c0e9d-5c5b-4aca-8e64-333333333335","title":"Coin Change","topic":"Dynamic Programming","description":"Given coins and amount, return fewest coins to make amount or -1.","solutionJava":"class Solution {\n  public int coinChange(int[] coins, int amount) {\n    int[] dp=new int[amount+1]; java.util.Arrays.fill(dp, amount+1); dp[0]=0;\n    for(int c: coins) for(int a=c;a<=amount;a++) dp[a]=Math.min(dp[a], dp[a-c]+1);\n    return dp[amount]>amount? -1: dp[amount];\n  }\n}"},
  {"id":"3a0c0e9d-5c5b-4aca-8e64-333333333336","title":"Longest Increasing Subsequence","topic":"Dynamic Programming","description":"Return length of the longest strictly increasing subsequence.","solutionJava":"class Solution {\n  public int lengthOfLIS(int[] nums) {\n    int[] tails=new int[nums.length]; int size=0;\n    for(int x: nums){ int l=0,r=size; while(l<r){ int m=(l+r)/2; if(tails[m]<x) l=m+1; else r=m; } tails[l]=x; if(l==size) size++; }\n    return size;\n  }\n}"},
  {"id":"3a0c0e9d-5c5b-4aca-8e64-333333333337","title":"Edit Distance","topic":"Dynamic Programming","description":"Compute Levenshtein distance between two strings.","solutionJava":"class Solution {\n  public int minDistance(String a, String b) {\n    int n=a.length(), m=b.length(); int[][] dp=new int[n+1][m+1];\n    for(int i=0;i<=n;i++) dp[i][0]=i; for(int j=0;j<=m;j++) dp[0][j]=j;\n    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){ if(a.charAt(i-1)==b.charAt(j-1)) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])); }\n    return dp[n][m];\n  }\n}"}
]
